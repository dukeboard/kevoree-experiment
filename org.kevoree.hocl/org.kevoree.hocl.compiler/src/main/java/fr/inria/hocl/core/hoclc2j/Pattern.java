package fr.inria.hocl.core.hoclc2j;


import java.util.*;

public class Pattern implements Symbols {

	// private LinkedList<AtomPattern> patDesc; // commonly called a
	// "symbols table"
	// public ReactionCondition decompCond; // conditions generated by pattern
	// shortcuts (literals and, maybe non linear variables)
	// int nbAtoms;
	// int nbMoleculeVars; // counter of number of molecule variables
	// Set<String> subVars;
	// Set<String> jokers;
	// int nestLevel;
	List<MoleculeVarPat> moleculeVars;

	List<AtomPattern> atomVars;

	private static int iterArrayCounter;


	public Pattern() { // int nestLevel) {
		// patDesc = new LinkedList<AtomPattern>();
		// decompCond = new ReactionCondition();
		// subVars = new HashSet<String>();
		// jokers = new HashSet<String>();
		moleculeVars = new LinkedList<MoleculeVarPat>();
		atomVars = new LinkedList<AtomPattern>();
		// nbAtoms = 0;
		// nbMoleculeVars = 0;
		// this.nestLevel = nestLevel;
		iterArrayCounter = 0;
	}


	public int length() {
		return atomVars.size();
	}


	public void addAtomPattern( AtomPattern atomPattern ) {
		atomVars.add( atomPattern );
	}


	public void addMoleculePattern( MoleculeVarPat moleculeVarPat ) {
		moleculeVarPat.setPosition( moleculeVars.size() );
		moleculeVars.add( moleculeVarPat );
	}


	public Symbols lookUp( String ident ) {
		Symbols symbols = null;
		Iterator<AtomPattern> it = atomVars.iterator();
		while( it.hasNext() && symbols == null ) {
			symbols = it.next().lookUp( ident );
		}
		if( symbols == null && moleculeVars.size() > 0 ) {
			Iterator<MoleculeVarPat> itMol = moleculeVars.iterator();
			while( itMol.hasNext() && symbols == null ) {
				symbols = itMol.next().lookUp( ident );
			}
		}
		return symbols;
	}


	public Set<Symbols> getVariables() {
		Set<Symbols> vars = new HashSet<Symbols>();
		Iterator<AtomPattern> it = atomVars.iterator();
		AtomPattern atomPattern;
		while( it.hasNext() ) {
			atomPattern = it.next();
			vars.addAll( atomPattern.getVariables() );
		}
		Iterator<MoleculeVarPat> itMol = moleculeVars.iterator();
		MoleculeVarPat molVarPat;
		while( itMol.hasNext() ) {
			molVarPat = itMol.next();
			vars.add( molVarPat );
		}
		return vars;
	}


	public boolean setLastReactionCondition( External cond ) {
		boolean done = false;
		ListIterator<AtomPattern> it = atomVars.listIterator();
		AtomPattern atomPattern = null;
		while( it.hasNext() ) {
			atomPattern = it.next();
		}
		while( !done && it.hasPrevious() ) {
			if (atomPattern != null) {
				done = atomPattern.setLastReactionCondition( cond );
			}
			atomPattern = it.previous();
		}
		return done;
	}


	public String generatePatternDeclaration( String permutation,
			SymbolsTable symbolsTable, String reactionRuleName ) {
		String s;
		String atomVarArray;
		String molVarArray;

		atomVarArray = "_HOCL_atomIteratorArray" + iterArrayCounter;
		s = generateAtomIteratorArray( reactionRuleName, symbolsTable );
		molVarArray = "_HOCL_moleculeIteratorArray" + iterArrayCounter;
		s = s + "\n" + generateMoleculeIteratorArray( symbolsTable ) + "\n"
				+ permutation + " = newPermutation(" + atomVarArray + ", "
				+ molVarArray + ");";
		iterArrayCounter++;
		return s;
	}


	private String generateAtomIteratorArray( String reactionRuleName,
			SymbolsTable symbolsTable ) {
		Iterator<AtomPattern> it = atomVars.iterator();
		AtomPattern atomPattern;
		int position = -1;
		String patVar = "_HOCL_atomIteratorArray" + iterArrayCounter;

		String s = "AtomIterator[] " + patVar + ";\n" + patVar + " = new AtomIterator["
				+ atomVars.size() + "];\n";
		while( it.hasNext() ) {
			atomPattern = it.next();
			if( !( atomPattern instanceof MoleculeVarPat ) ) {
				position++;
				s = s
						+ "{\n"
						+ CodeGeneratorHelper.indentCode( atomPattern.generatePatClass( "permutation",
								reactionRuleName, symbolsTable ) ) + "\n" + "\t" + patVar + "["
						+ position + "] = "
						+ atomPattern.generatePatternNew( reactionRuleName ) + ";\n" + "}";
			}
			if( it.hasNext() ) {
				s = s + "\n";
			}
		}
		return s;
	}


	private String generateMoleculeIteratorArray( SymbolsTable symbolsTable ) {
		String s = "";
		Iterator<MoleculeVarPat> itMol = moleculeVars.iterator();
		int nbMoleculeVar = 0;
		String moleculeVar = "_HOCL_moleculeIteratorArray" + iterArrayCounter;
		int size = moleculeVars.size();

		while( itMol.hasNext() ) {
			MoleculeVarPat molVarPat = itMol.next();
			if( symbolsTable.peek() == this ) { // molecule var not inside a solution
																					// pattern
				s = s + moleculeVar + "[" + nbMoleculeVar
						+ "] = new MoleculeIterator(0);\n";
			} else {
				s = s + moleculeVar + "[" + nbMoleculeVar + "] = new MoleculeIterator("
						+ size + ");" + " // " + molVarPat.name + "\n";
			}
			nbMoleculeVar++;
		}
		s = "MoleculeIterator[] " + moleculeVar + " = new MoleculeIterator["
				+ moleculeVars.size() + "];" + ( s.length() > 0 ? "\n" + s : "" );
		return s;
	}


	public String generateDeclaration( Symbols variable, String permutation ) {
		// exceptionally second argument is a permutation not an iterator
		String s = "";
		Iterator<AtomPattern> it = atomVars.iterator();
		AtomPattern atomPattern;
		int position = 0;
		while( it.hasNext() && s.length() == 0 ) {
			atomPattern = it.next();
			Set<Symbols> patternVars = atomPattern.getVariables();
			if( patternVars.contains( variable ) ) {
				s = atomPattern.generateDeclaration( variable, permutation
						+ ".getAtomIterator(" + position + ")" );
			}
			position++;
		}
		if( s.length() == 0 ) {
			Iterator<MoleculeVarPat> itMol = moleculeVars.iterator();
			MoleculeVarPat molVarPat;
			while( itMol.hasNext() && s.length() == 0 ) {
				molVarPat = itMol.next();
				if( molVarPat == variable ) {
					s = molVarPat.generateDeclaration( variable, permutation );
				}
			}
		}
		return s;
	}


	public void setReactionRule( ReactionRule reactionRule ) {
		Iterator<AtomPattern> it = atomVars.iterator();
		AtomPattern atomPattern;
		while( it.hasNext() ) {
			atomPattern = it.next();
			atomPattern.setReactionRule( reactionRule );
		}
	}


	public String toString() {
		String s = "";
		for (AtomPattern atomVar : atomVars) {
			s = s + ", " + atomVar;
		}
		for (MoleculeVarPat moleculeVar : moleculeVars) {
			s = s + ", " + moleculeVar;
		}
		return s.length() > 2 ? s.substring( 2 ) : s;
	}


	public String generateIdent() {
		return ""; // no ident
	}


	public String generateVariableDecl() {
		return ""; // no ident => no declaration
	}


	public void setReadOnlyReactives( Molecule molecule ) {
		for (AtomPattern atomVar : atomVars) {
			atomVar.checkReadOnly(molecule);
		}
	}


	public boolean equalsMolecule( Molecule molecule ) {
		boolean equals;
		Iterator<AtomPattern> itPat = atomVars.iterator();
		// create a list to mark found atoms
		List<Boolean> marked = new LinkedList<Boolean>();
		for( int i = 1; i <= molecule.size(); i++ ) {
			marked.add( Boolean.FALSE );
		}
		equals = true;
		while( itPat.hasNext() && equals ) {
			AtomPattern atomPat = itPat.next();
			Iterator<Atom> itMol = molecule.iterator();
			ListIterator<Boolean> itMol2 = marked.listIterator();
			while( itMol.hasNext() && equals ) {
				Atom atom = itMol.next();
				if( !itMol2.next() ) {
					equals = atomPat.equalsAtom( atom );
				}
				if( equals ) {
					itMol2.set( Boolean.TRUE );
				}
			}
		}
		if( equals ) {
			Iterator<Boolean> it = marked.iterator();
			while( it.hasNext() && equals ) {
				equals = it.next();
			}
		}
		return equals;
	}

	/*
	 * public boolean equals(Pattern patternDesc){ boolean equals =
	 * (patDesc.size() == patternDesc.patDesc.size()); Iterator<AtomPattern> iter1
	 * = patDesc.iterator(); boolean found;
	 * 
	 * while(equals && iter1.hasNext()){ AtomPattern AtomPattern1 = iter1.next();
	 * Iterator<AtomPattern> iter2 = patternDesc.patDesc.iterator(); found =
	 * false; while(!found && iter2.hasNext()){ AtomPattern AtomPattern2 =
	 * iter2.next(); found = AtomPattern1.equals(AtomPattern2); } equals = found;
	 * } return equals; }
	 */

	/*
	 * public void addLast(AtomPattern AtomPattern) {
	 * patDesc.addLast(AtomPattern); if(AtomPattern instanceof AtomPatternJoker){
	 * nbJokers++; jokers.add(((AtomPatternJoker)AtomPattern).ident); } else {
	 * nbAtoms++; } subVars.addAll(AtomPattern.getVars()); }
	 */
	/*
	 * public AtomPattern removeLast() { AtomPattern AtomPattern =
	 * patDesc.getLast(); if(AtomPattern instanceof AtomPatternJoker){ nbJokers--;
	 * // FIXME: only Joker star for the moment
	 * jokers.remove(((AtomPatternJoker)AtomPattern).ident); } else { nbAtoms--; }
	 * subVars.removeAll(AtomPattern.getVars()); // patterns are linear return
	 * patDesc.removeLast(); }
	 */
	/*
	 * public AtomPattern getLast() { return patDesc.getLast(); }
	 */
	/*
	 * // return all variables of the pattern recursively, without the jokers
	 * public Set<String> getVars() { Set<String> s = new HashSet<String>();
	 * Iterator<AtomPattern> it = patDesc.iterator(); AtomPattern vd; while
	 * (it.hasNext()) { vd = it.next(); s.addAll(vd.getVars()); } return s; }
	 */
	/*
	 * public Set<String> getJokers() { Set<String> s = new HashSet<String>();
	 * Iterator<AtomPattern> it = patDesc.iterator(); AtomPattern vd; while
	 * (it.hasNext()) { vd = it.next(); s.addAll(vd.getJokers()); } return s; }
	 */

	/*
	 * public AtomPattern lookUp(String ident){ Iterator<AtomPattern> it;
	 * AtomPattern AtomPattern, result;
	 * 
	 * result = null; it = patDesc.iterator(); while (it.hasNext() && result ==
	 * null) { AtomPattern = it.next(); result = AtomPattern.lookUp(ident); }
	 * return result; }
	 */

	/**
	 * 
	 * @param AtomPattern
	 * @return the first variable descriptor equals to AtomPattern in this pattern
	 *         descriptor
	 */
	/*
	 * public AtomPattern find(AtomPattern AtomPattern){ Iterator<AtomPattern>
	 * iter = patDesc.iterator(); boolean found = false; AtomPattern result =
	 * null;
	 * 
	 * while(!found && iter.hasNext()){ result = iter.next(); found =
	 * result.equals(AtomPattern); } return result; }
	 * 
	 * public void pushCond(ReactionCondition decompCond){ Iterator<AtomPattern>
	 * it = patDesc.iterator(); AtomPattern AtomPattern; while(it.hasNext()){
	 * AtomPattern = it.next(); AtomPattern.pushCond(decompCond); } }
	 * 
	 * 
	 * public void applyCondOpt(Set<String> assignedVars, ReactionCondition
	 * decompCond) { orderVariables(decompCond); applyCond(assignedVars,
	 * decompCond); if(decompCond.size() != 0){
	 * Hoclc2j.stopError("All sub-conditions have not been applied: " +
	 * decompCond); } applyCondOfBool(); }
	 * 
	 * static private class OccurrencesComparator implements
	 * Comparator<AtomPattern> { public int compare(AtomPattern o1, AtomPattern
	 * o2) { return o2.getNbOcc() - o1.getNbOcc(); } }
	 * 
	 * private void orderVariables(ReactionCondition decompCond) { // compute
	 * "occurrences" of variables in the condition Iterator<PrimaryCondition>
	 * itCond; PrimaryCondition primCond; Iterator<AtomPattern> it; AtomPattern
	 * AtomPattern;
	 * 
	 * itCond = decompCond.iterator(); while (itCond.hasNext()) { primCond =
	 * itCond.next(); it = patDesc.iterator(); while (it.hasNext()) { AtomPattern
	 * = it.next(); if (primCond.variables.containsAll(AtomPattern.getVars())) {
	 * AtomPattern.incrNbOcc(); } } } // reorder according to the number of
	 * occurrences Collections.sort(patDesc, new OccurrencesComparator()); }
	 * 
	 * 
	 * public void applyCond(Set<String> assignedVars, ReactionCondition
	 * decompCond) { // apply the partial reaction conditions as soon as possible
	 * Iterator<AtomPattern> it; AtomPattern AtomPattern;
	 * 
	 * it = patDesc.iterator(); while(it.hasNext()){ AtomPattern = it.next();
	 * AtomPattern.applyCond(assignedVars, decompCond); } }
	 * 
	 * public void applyCondOfBool() { Iterator<AtomPattern> it; AtomPattern
	 * AtomPattern;
	 * 
	 * it = patDesc.iterator(); while (it.hasNext()) { AtomPattern = it.next();
	 * AtomPattern.applyCondOfBool(); } }
	 */
	/*
	 * public String generateAtomIteratorArray(Pattern allDesc, int nestLevel) {
	 * String s = new String(); Iterator<AtomPattern> it = patDesc.iterator();
	 * AtomPattern AtomPattern; int position = -1; String patVar =
	 * "_HOCL_atomIteratorArray" + nestLevel; Set<String> assignedVars = new
	 * HashSet<String>();
	 * 
	 * s = "AtomIterator[] " + patVar + ";\n" + patVar + " = new AtomIterator[" +
	 * nbAtoms + "];\n"; // FIXME: NB_ATOMS while(it.hasNext()){ AtomPattern =
	 * it.next(); if(!(AtomPattern instanceof AtomPatternJoker)){ position++; s =
	 * s + "{\n" + Hoclc2j.indentCode(AtomPattern.generatePatClass(allDesc,
	 * assignedVars, "permutation")) + "\n" + // , nestLevel "\t" + patVar + "[" +
	 * position + "] = " + AtomPattern.generateNewPat() + ";\n" + // nestLevel
	 * "}"; assignedVars.addAll(AtomPattern.getVars()); } if(it.hasNext()){ s = s
	 * + "\n"; } } return s; }
	 * 
	 * 
	 * public String generateMoleculeIteratorArray(Pattern allDesc, int
	 * nestLevel){ String s = new String(); Iterator<AtomPattern> it =
	 * patDesc.iterator(); AtomPattern AtomPattern; int nbJoker = 0; String jsVar
	 * = "_HOCL_moleculeIteratorArray" + nestLevel;
	 * 
	 * while(it.hasNext()){ AtomPattern = it.next(); if(AtomPattern instanceof
	 * AtomPatternJoker){ if(allDesc == this){ // joker not inside a solution
	 * pattern s = s + jsVar + "[" + nbJoker + "] = new MoleculeIterator(0);\n"; }
	 * else { s = s + ( nbJoker + 1 < nbJokers ? jsVar + "[" + nbJoker +
	 * "] = new MoleculeIterator(" + nbJokers + ");\n" : jsVar + "[" + nbJoker +
	 * "] = new MoleculeIterator(" + nbJokers + ");") + " // " +
	 * ((AtomPatternJoker)AtomPattern).ident + "\n"; } nbJoker++; } } s =
	 * "MoleculeIterator[] " + jsVar + " = new MoleculeIterator[" + nbJokers +
	 * "];" + (s.length() > 0 ? "\n" + s : ""); return s; }
	 * 
	 * 
	 * public String generatePatternDeclaration(String permutation, Pattern
	 * allDesc, int nestLevel) { String s; String patVar =
	 * "_HOCL_atomIteratorArray" + nestLevel; String jsVar =
	 * "_HOCL_moleculeIteratorArray" + nestLevel;
	 * 
	 * s = generateAtomIteratorArray(allDesc,nestLevel) + "\n" +
	 * generateMoleculeIteratorArray(allDesc,nestLevel) + "\n" + permutation +
	 * " = newPermutation(" + patVar + ", " + jsVar + ");"; return s; }
	 * 
	 * 
	 * public String generateDeclaration(String ident, Pattern allDesc, String
	 * permutation){ String s = new String(); String decl; Iterator<AtomPattern>
	 * it; AtomPattern AtomPattern; int position = -1; int posJoker = -1;
	 * 
	 * it = patDesc.iterator(); while(it.hasNext()){ AtomPattern = it.next();
	 * position++; String atomIterator = permutation + ".getAtomIterator(" +
	 * position + ")"; if(AtomPattern instanceof AtomPatternJoker){ // FIXME:
	 * horrible hack posJoker++;
	 * ((AtomPatternJoker)AtomPattern).setPosJoker(posJoker); atomIterator =
	 * permutation; } decl = AtomPattern.generateDeclarations(ident, allDesc,
	 * atomIterator); if(s.length() == 0){ s = decl; } else { s = s + "\n" + decl;
	 * } } return s; }
	 * 
	 * private String genDecl(String ident, Pattern allDesc, String permutation){
	 * String s = new String(); AtomPattern AtomPattern; AtomPattern =
	 * lookUp(ident); // FIXME: if rr name => lookUp in the stack if(AtomPattern
	 * != null){ s = AtomPattern.generateVarDecl() + ";"; } if(s.length() > 0){ s
	 * = s + "\n"; } s = s + generateDeclaration(ident, allDesc, permutation);
	 * return s; }
	 * 
	 * public String generateDeclarations(Set<String> vars, Pattern allDesc,
	 * String permutation) { String s = new String(); String decl;
	 * 
	 * Iterator<String> it; String ident;
	 * 
	 * it = vars.iterator(); while(it.hasNext()){ ident = it.next(); decl =
	 * genDecl(ident, allDesc, permutation); if(s.length() == 0){ s = decl; } else
	 * { s = s + "\n" + decl; } } return s; }
	 */
}
