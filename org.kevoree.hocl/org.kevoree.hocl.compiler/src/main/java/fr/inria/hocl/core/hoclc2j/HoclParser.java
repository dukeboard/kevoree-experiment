/* Generated By:JavaCC: Do not edit this line. HoclParser.java */
package fr.inria.hocl.core.hoclc2j;


import java.util.StringTokenizer;

/**
 * Grammar to parse Java version 1.5
 * 
 * @author Sreenivasa Viswanadha - Simplified and enhanced for 1.5
 */
public class HoclParser implements HoclParserConstants {

	/**
	 * Class to hold modifiers.
	 */
	static public final class ModifierSet {

		/* Definitions of the bits in the modifiers field. */
		public static final int PUBLIC = 0x0001;

		public static final int PROTECTED = 0x0002;

		public static final int PRIVATE = 0x0004;

		public static final int ABSTRACT = 0x0008;

		public static final int STATIC = 0x0010;

		public static final int FINAL = 0x0020;

		public static final int SYNCHRONIZED = 0x0040;

		public static final int NATIVE = 0x0080;

		public static final int TRANSIENT = 0x0100;

		public static final int VOLATILE = 0x0200;

		public static final int STRICTFP = 0x1000;


		/**
		 * A set of accessors that indicate whether the specified modifier is in the
		 * set.
		 * @param modifiers
		 * @return
		 */

		public boolean isPublic( int modifiers ) {
			return ( modifiers & PUBLIC ) != 0;
		}


		public boolean isProtected( int modifiers ) {
			return ( modifiers & PROTECTED ) != 0;
		}


		public boolean isPrivate( int modifiers ) {
			return ( modifiers & PRIVATE ) != 0;
		}


		public boolean isStatic( int modifiers ) {
			return ( modifiers & STATIC ) != 0;
		}


		public boolean isAbstract( int modifiers ) {
			return ( modifiers & ABSTRACT ) != 0;
		}


		public boolean isFinal( int modifiers ) {
			return ( modifiers & FINAL ) != 0;
		}


		public boolean isNative( int modifiers ) {
			return ( modifiers & NATIVE ) != 0;
		}


		public boolean isStrictfp( int modifiers ) {
			return ( modifiers & STRICTFP ) != 0;
		}


		public boolean isSynchronized( int modifiers ) {
			return ( modifiers & SYNCHRONIZED ) != 0;
		}


		public boolean isTransient( int modifiers ) {
			return ( modifiers & TRANSIENT ) != 0;
		}


		public boolean isVolatile( int modifiers ) {
			return ( modifiers & VOLATILE ) != 0;
		}


		/**
		 * Removes the given modifier.
		 * @param modifiers
		 * @param mod
		 * @return
		 */
		static int removeModifier( int modifiers, int mod ) {
			return modifiers & ~mod;
		}
	}


	final public Token Lsol() throws ParseException {
		Token t;
		t = jj_consume_token( LT );
		{
			if( true )
				return t;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Token Rsol() throws ParseException {
		Token t;
		t = jj_consume_token( GT );
		{
			if( true )
				return t;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Token Equals() throws ParseException {
		Token t;
		t = jj_consume_token( ASSIGN );
		{
			if( true )
				return t;
		}
		throw new Error( "Missing return statement in function" );
	}


	/****************************************
	 * THE HOCL LANGUAGE GRAMMAR STARTS HERE *
	 *****************************************/
	final public Program Start() throws ParseException {
		Program prgm;
		prgm = Program( new SymbolsTable() );
		jj_consume_token( 0 );

		{
			if( true )
				return prgm;
		}

		throw new Error( "Missing return statement in function" );
	}


	final public Program Program( SymbolsTable symbolsTable )
			throws ParseException {
		Solution sol;
		String decl = "", decl2;
		StringTokenizer sToken;
		String pkgName = "";
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case ABSTRACT:
		case FINAL:
		case NATIVE:
		case PACKAGE:
		case PRIVATE:
		case PROTECTED:
		case PUBLIC:
		case STATIC:
		case STRICTFP:
		case SYNCHRONIZED:
		case TRANSIENT:
		case VOLATILE:
			decl = PackageDeclaration();
			break;
		default:
			jj_la1[0] = jj_gen;
			;
		}
		label_1: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case IMPORT:

				break;
			default:
				jj_la1[1] = jj_gen;
				break label_1;
			}
			decl2 = ImportDeclaration();
			decl = decl + "\n" + decl2;
		}
		sToken = new StringTokenizer( decl );
		while( sToken.hasMoreTokens() ) {
			String currToken = sToken.nextToken();
			if( currToken.equalsIgnoreCase( "package" ) && sToken.hasMoreTokens() ) {
				pkgName = new StringTokenizer( sToken.nextToken(), ";" ).nextToken();
				break;
			}
		}
		sol = LetSolution( symbolsTable );
		{
			if( true )
				return new Program( sol, decl, pkgName );
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Solution LetSolution( SymbolsTable symbolsTable )
			throws ParseException {
		Token t;
		boolean isRec = false;
		Solution sol;
		ReactionRulePat rulePat;
		ReactionRule reactRule;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case LT:
			sol = Solution( symbolsTable );
			{
				if( true )
					return sol;
			}
			break;
		case LET:
			jj_consume_token( LET );
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case REC:
				jj_consume_token( REC );
				isRec = true;
				break;
			default:
				jj_la1[2] = jj_gen;
				;
			}
			t = jj_consume_token( IDENTIFIER );
			rulePat = new ReactionRulePat( t.image, t.image );
			if( isRec ) {
				symbolsTable.push( rulePat );
			}
			Equals();
			reactRule = Abstraction( symbolsTable );
			if( !isRec ) {
				symbolsTable.push( rulePat );
			}
			reactRule.setRuleName( t.image );
			rulePat.setReactionRule( reactRule );
			jj_consume_token( IN );
			sol = LetSolution( symbolsTable );
			symbolsTable.pop();
			{
				if( true )
					return new SolutionWithRuleDef( sol, rulePat );
			}
			break;
		default:
			jj_la1[3] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public BasicSolution Solution( SymbolsTable symbolsTable )
			throws ParseException {
		Molecule mol;
		symbolsTable.incrNestLevel();
		Lsol();
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case FALSE:
		case NEW:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case REPLACE:
		case REPLACE_ONE:
		case LET:
		case IDENTIFIER:
		case LPAREN:
		case LT:
		case BANG:
		case TILDE:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
			mol = Molecule( symbolsTable );
			Rsol();
			symbolsTable.decrNestLevel();
			{
				if( true )
					return new BasicSolution( mol, symbolsTable.getNestLevel() );
			}
			break;
		case GT:
			Rsol();
			symbolsTable.decrNestLevel();
			{
				if( true )
					return new BasicSolution( new BasicMolecule( symbolsTable
							.getNestLevel(), symbolsTable ), symbolsTable.getNestLevel() );
			}
			break;
		default:
			jj_la1[4] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Molecule Molecule( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		BasicMolecule mol = new BasicMolecule( symbolsTable.getNestLevel(),
				symbolsTable );
		Molecule molecule;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case FALSE:
		case NEW:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case REPLACE:
		case REPLACE_ONE:
		case IDENTIFIER:
		case LPAREN:
		case LT:
		case BANG:
		case TILDE:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
			atom = Atom( symbolsTable );
			mol.addLast( atom );
			label_2: while( true ) {
				if( jj_2_1( 2 ) ) {
					;
				} else {
					break label_2;
				}
				jj_consume_token( COMMA );
				atom = Atom( symbolsTable );
				mol.addLast( atom );
			}
			{
				if( true )
					return mol;
			}
			break;
		case LET:
			molecule = LetReactionRule( symbolsTable );
			{
				if( true )
					return molecule;
			}
			break;
		default:
			jj_la1[5] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom Atom( SymbolsTable symbolsTable ) throws ParseException {
		boolean isTuple = false;
		Atom atom, atom2;
		Tuple tuple = null;
		atom = Expression( symbolsTable );
		label_3: while( true ) {
			if( jj_2_2( 2 ) ) {
				;
			} else {
				break label_3;
			}
			jj_consume_token( COLON );
			atom2 = Expression( symbolsTable );
			if( !isTuple ) {
				isTuple = true;
				tuple = new Tuple( symbolsTable.getNestLevel() );
				tuple.add( atom );
			}
			tuple.add( atom2 );
		}
		if( tuple == null ) {
			{
				if( true )
					return atom;
			}
		} else {
			{
				if( true )
					return tuple;
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public MoleculeWithRuleDef LetReactionRule( SymbolsTable symbolsTable )
			throws ParseException {
		Token t;
		boolean isRec = false;
		ReactionRulePat rulePat;
		Molecule mol;
		ReactionRule reactRule;
		jj_consume_token( LET );
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case REC:
			jj_consume_token( REC );
			isRec = true;
			break;
		default:
			jj_la1[6] = jj_gen;
			;
		}
		t = jj_consume_token( IDENTIFIER );
		rulePat = new ReactionRulePat( t.image, t.image );
		if( isRec ) {
			symbolsTable.push( rulePat );
		}
		Equals();
		reactRule = Abstraction( symbolsTable );
		if( !isRec ) {
			symbolsTable.push( rulePat );
		}
		reactRule.setRuleName( t.image );
		rulePat.setReactionRule( reactRule );
		jj_consume_token( IN );
		mol = Molecule( symbolsTable );
		symbolsTable.pop();
		{
			if( true )
				return new MoleculeWithRuleDef( mol, rulePat );
		}
		throw new Error( "Missing return statement in function" );
	}


	final public ReactionRule ReactionRule( SymbolsTable symbolsTable )
			throws ParseException {
		Token t;
		ReactionRule reactRule;
		String ruleName = new String();
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case IDENTIFIER:
			t = jj_consume_token( IDENTIFIER );
			ruleName = t.image;
			Equals();
			break;
		default:
			jj_la1[7] = jj_gen;
			;
		}
		reactRule = Abstraction( symbolsTable );
		reactRule.setRuleName( ruleName );
		{
			if( true )
				return reactRule;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public ReactionRule Abstraction( SymbolsTable symbolsTable )
			throws ParseException {
		Pattern pat = new Pattern();
		symbolsTable.push( pat );
		Molecule mol;
		Atom cond;
		ReactionRule reactRule = new ReactionRule( "" );
		symbolsTable.incrNestLevel();
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case REPLACE:
			jj_consume_token( REPLACE );
			reactRule.setNShot();
			break;
		case REPLACE_ONE:
			jj_consume_token( REPLACE_ONE );
			reactRule.setOneShot();
			break;
		default:
			jj_la1[8] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		PatternMol( symbolsTable, pat );
		reactRule.setPattern( pat );
		reactRule.setSymbolsTable( symbolsTable );
		symbolsTable.decrNestLevel();
		jj_consume_token( BY );
		mol = Molecule( symbolsTable );
		reactRule.result = mol;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case IF:
			jj_consume_token( IF );
			cond = ConditionalOrExpression( symbolsTable );
			reactRule.condition = ( External ) cond;
			pat.setLastReactionCondition( reactRule.condition );
			break;
		default:
			jj_la1[9] = jj_gen;
			;
		}
		symbolsTable.pop(); // pattern descriptor
		{
			if( true )
				return reactRule;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Pattern PatternMol( SymbolsTable symbolsTable, Pattern pat )
			throws ParseException {
		// Pattern pat = new Pattern();
		AtomPattern atomPat;
		MoleculeVarPat moleculePat;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case FALSE:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case LPAREN:
		case LT:
			atomPat = PatternTuple( symbolsTable );
			pat.addAtomPattern( atomPat );
			break;
		case HOOK:
			moleculePat = PatternMoleculeVar( symbolsTable );
			pat.addMoleculePattern( moleculePat );
			break;
		default:
			jj_la1[10] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		label_4: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case COMMA:
				;
				break;
			default:
				jj_la1[11] = jj_gen;
				break label_4;
			}
			jj_consume_token( COMMA );
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case FALSE:
			case NULL:
			case TRUE:
			case INTEGER_LITERAL:
			case FLOATING_POINT_LITERAL:
			case CHARACTER_LITERAL:
			case STRING_LITERAL:
			case IDENTIFIER:
			case LPAREN:
			case LT:
				atomPat = PatternTuple( symbolsTable );
				pat.addAtomPattern( atomPat );
				break;
			case HOOK:
				moleculePat = PatternMoleculeVar( symbolsTable );
				pat.addMoleculePattern( moleculePat );
				break;
			default:
				jj_la1[12] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		{
			if( true )
				return pat;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public AtomPattern PatternTuple( SymbolsTable symbolsTable )
			throws ParseException {
		boolean firstTime = true;
		AtomPattern atomPat;
		TuplePat tuplePat = null;
		symbolsTable.incrNestLevel();
		atomPat = PatternAtom( symbolsTable );
		label_5: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case COLON:
				;
				break;
			default:
				jj_la1[13] = jj_gen;
				break label_5;
			}
			jj_consume_token( COLON );
			if( firstTime ) {
				tuplePat = new TuplePat( symbolsTable.getNestLevel() );
				tuplePat.add( atomPat );
				firstTime = false;
			}
			atomPat = PatternAtom( symbolsTable );
			tuplePat.add( atomPat );
		}
		symbolsTable.decrNestLevel();
		if( tuplePat == null ) {
			{
				if( true )
					return atomPat;
			}
		} else {
			{
				if( true )
					return tuplePat;
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public MoleculeVarPat PatternMoleculeVar( SymbolsTable symbolsTable )
			throws ParseException {
		Token t;
		jj_consume_token( HOOK );
		// FIXME: replace by nothing
		t = jj_consume_token( IDENTIFIER );
		{
			if( true )
				return new MoleculeVarPat( t.image );
		}
		throw new Error( "Missing return statement in function" );
	}


	final public AtomPattern PatternAtom( SymbolsTable symbolsTable )
			throws ParseException {
		Token t, t2;
		String javaType;
		AtomPattern atomPat;
		Atom atom;
		Pattern pat = new Pattern();
		External ext;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case LPAREN:
			jj_consume_token( LPAREN );
			atomPat = PatternTuple( symbolsTable );
			jj_consume_token( RPAREN );
			{
				if( true )
					return atomPat;
			}
			break;
		default:
			jj_la1[14] = jj_gen;
			if( jj_2_3( 2 ) ) {
				t = jj_consume_token( IDENTIFIER );
				Equals();
				t2 = jj_consume_token( IDENTIFIER );
				{
					if( true )
						return new ReactionRulePat( t.image, t2.image );
				}
			} else {
				switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
				case LT:
					Lsol();
					PatternMol( symbolsTable, pat );
					Rsol();
					{
						if( true )
							return new SolutionPat( pat, symbolsTable.getNestLevel() );
					}
					break;
				case FALSE:
				case NULL:
				case TRUE:
				case INTEGER_LITERAL:
				case FLOATING_POINT_LITERAL:
				case CHARACTER_LITERAL:
				case STRING_LITERAL:
					// literal (cf Java grammar)
					ext = Literal();
					{
						if( true )
							return new LiteralPat( ext, ( Pattern ) symbolsTable.peek() );
					}
					break;
				case IDENTIFIER:
					// external/Java object with Java type
					t = jj_consume_token( IDENTIFIER );
					jj_consume_token( TWO_COLONS );
					javaType = Type();
					{
						if( true )
							return new AtomVarPat( t.image, javaType,
									( Pattern ) symbolsTable.peek() );
					}
					break;
				default:
					jj_la1[15] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
				}
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	/*****************************************
	 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
	 *****************************************/

	/*
	 * Program structuring syntax follows.
	 * 
	 * 
	 * void CompilationUnit(): {} { [ LOOKAHEAD( ( Annotation() )* "package" )
	 * PackageDeclaration() ] ( ImportDeclaration() )* ( TypeDeclaration() )* ( <
	 * "" > )? ( <STUFF_TO_IGNORE: ~[]> )? <EOF> }
	 */
	final public String PackageDeclaration() throws ParseException {
		String s, packName;
		s = Modifiers();
		jj_consume_token( PACKAGE );
		// Name()
		packName = PackageName();
		jj_consume_token( SEMICOLON );
		{
			if( true )
				return ( s.length() > 0 ? s : "" ) + "package " + packName + ";";
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String ImportDeclaration() throws ParseException {
		String s, packName;
		jj_consume_token( IMPORT );
		s = "import";
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case STATIC:
			jj_consume_token( STATIC );
			s = s + " static";
			break;
		default:
			jj_la1[16] = jj_gen;
			;
		}
		packName = PackageName();
		s = s + " " + packName;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case DOT:
			jj_consume_token( DOT );
			jj_consume_token( STAR );
			s = s + ".*";
			break;
		default:
			jj_la1[17] = jj_gen;
			;
		}
		jj_consume_token( SEMICOLON );
		s = s + ";";
		{
			if( true )
				return s;
		}
		throw new Error( "Missing return statement in function" );
	}


	/*
	 * Modifiers. We match all modifiers in a single rule to reduce the chances of
	 * syntax errors for simple modifier mistakes. It will also enable us to give
	 * better error messages.
	 */
	final public String Modifiers() throws ParseException {
		int modifiers = 0;
		String s = new String();
		label_6: while( true ) {
			if( jj_2_4( 2 ) ) {
				;
			} else {
				break label_6;
			}
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case PUBLIC:
				jj_consume_token( PUBLIC );
				s = s + " public";
				modifiers |= ModifierSet.PUBLIC;
				break;
			case STATIC:
				jj_consume_token( STATIC );
				s = s + " static";
				modifiers |= ModifierSet.STATIC;
				break;
			case PROTECTED:
				jj_consume_token( PROTECTED );
				s = s + " protected";
				modifiers |= ModifierSet.PROTECTED;
				break;
			case PRIVATE:
				jj_consume_token( PRIVATE );
				s = s + " private";
				modifiers |= ModifierSet.PRIVATE;
				break;
			case FINAL:
				jj_consume_token( FINAL );
				s = s + " final";
				modifiers |= ModifierSet.FINAL;
				break;
			case ABSTRACT:
				jj_consume_token( ABSTRACT );
				s = s + " abstract";
				modifiers |= ModifierSet.ABSTRACT;
				break;
			case SYNCHRONIZED:
				jj_consume_token( SYNCHRONIZED );
				s = s + " synchronized";
				modifiers |= ModifierSet.SYNCHRONIZED;
				break;
			case NATIVE:
				jj_consume_token( NATIVE );
				s = s + " native";
				modifiers |= ModifierSet.NATIVE;
				break;
			case TRANSIENT:
				jj_consume_token( TRANSIENT );
				s = s + " transient";
				modifiers |= ModifierSet.TRANSIENT;
				break;
			case VOLATILE:
				jj_consume_token( VOLATILE );
				s = s + " volatile";
				modifiers |= ModifierSet.VOLATILE;
				break;
			case STRICTFP:
				jj_consume_token( STRICTFP );
				s = s + " strictfp";
				modifiers |= ModifierSet.STRICTFP;
				break;
			default:
				jj_la1[18] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		{
			if( true )
				return ( s.length() > 0 ) ? s.substring( 1 ) : "";
		}
		throw new Error( "Missing return statement in function" );
	}


	/*
	 * Declaration syntax follows.
	 * 
	 * void TypeDeclaration(): { int modifiers; } { ";" | modifiers = Modifiers()
	 * ( ClassOrInterfaceDeclaration(modifiers) | EnumDeclaration(modifiers) |
	 * AnnotationTypeDeclaration(modifiers) ) }
	 * 
	 * 
	 * void ClassOrInterfaceDeclaration(int modifiers): { boolean isInterface =
	 * false; } { ( "class" | "interface" { isInterface = true; } ) <IDENTIFIER> [
	 * TypeParameters() ] [ ExtendsList(isInterface) ] [
	 * ImplementsList(isInterface) ] ClassOrInterfaceBody(isInterface) }
	 * 
	 * void ExtendsList(boolean isInterface): { boolean extendsMoreThanOne =
	 * false; } { "extends" ClassOrInterfaceType() ( "," ClassOrInterfaceType() {
	 * extendsMoreThanOne = true; } )* { if (extendsMoreThanOne && !isInterface)
	 * throw new
	 * ParseException("A class cannot extend more than one other class"); } }
	 * 
	 * void ImplementsList(boolean isInterface): {} { "implements"
	 * ClassOrInterfaceType() ( "," ClassOrInterfaceType() )* { if (isInterface)
	 * throw new ParseException("An interface cannot implement other interfaces");
	 * } }
	 * 
	 * void EnumDeclaration(int modifiers): {} { "enum" <IDENTIFIER> [
	 * ImplementsList(false) ] EnumBody() }
	 * 
	 * void EnumBody(): {} { "{" [ EnumConstant() ( LOOKAHEAD(2) ","
	 * EnumConstant() )* ] [ "," ] [ ";" ( ClassOrInterfaceBodyDeclaration(false)
	 * )* ] "}" }
	 * 
	 * void EnumConstant(): {} { Modifiers() <IDENTIFIER> [ Arguments() ] [
	 * ClassOrInterfaceBody(false) ] }
	 * 
	 * void TypeParameters(): {} { "<" TypeParameter() ( "," TypeParameter() )*
	 * ">" }
	 * 
	 * void TypeParameter(): {} { <IDENTIFIER> [ TypeBound() ] }
	 * 
	 * void TypeBound(): {} { "extends" ClassOrInterfaceType() ( "&"
	 * ClassOrInterfaceType() )* }
	 * 
	 * void ClassOrInterfaceBody(boolean isInterface): {} { "{" (
	 * ClassOrInterfaceBodyDeclaration(isInterface) )* "}" }
	 * 
	 * void ClassOrInterfaceBodyDeclaration(boolean isInterface): { boolean
	 * isNestedInterface = false; int modifiers; } { LOOKAHEAD(2) Initializer() {
	 * if (isInterface) throw new
	 * ParseException("An interface cannot have initializers"); } | modifiers =
	 * Modifiers() // Just get all the modifiers out of the way. If you want to do
	 * // more checks, pass the modifiers down to the member (
	 * ClassOrInterfaceDeclaration(modifiers) | EnumDeclaration(modifiers) |
	 * LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> "(" ) ConstructorDeclaration()
	 * | LOOKAHEAD( Type() <IDENTIFIER> ( "[" "]" )* ( "," | "=" | ";" ) )
	 * FieldDeclaration(modifiers) | MethodDeclaration(modifiers) ) | ";" }
	 * 
	 * void FieldDeclaration(int modifiers): {} { // Modifiers are already matched
	 * in the caller Type() VariableDeclarator() ( "," VariableDeclarator() )* ";"
	 * }
	 * 
	 * void VariableDeclarator(): {} { VariableDeclaratorId() [ "="
	 * VariableInitializer() ] }
	 * 
	 * void VariableDeclaratorId(): {} { <IDENTIFIER> ( "[" "]" )* }
	 */
	final public Atom VariableInitializer( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case LBRACE:
			atom = ArrayInitializer( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		case FALSE:
		case NEW:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case REPLACE:
		case REPLACE_ONE:
		case IDENTIFIER:
		case LPAREN:
		case LT:
		case BANG:
		case TILDE:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
			atom = Expression( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		default:
			jj_la1[19] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public External ArrayInitializer( SymbolsTable symbolsTable )
			throws ParseException {
		External ext = new External(), ext2;
		Atom atom;
		jj_consume_token( LBRACE );
		ext.javaExpression = "{";
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case FALSE:
		case NEW:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case REPLACE:
		case REPLACE_ONE:
		case IDENTIFIER:
		case LPAREN:
		case LBRACE:
		case LT:
		case BANG:
		case TILDE:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
			atom = VariableInitializer( symbolsTable );
			Hoclc2j.checkExternal( atom );
			ext2 = ( External ) atom;
			ext.javaExpression = ext.javaExpression + ext2.javaExpression;
			label_7: while( true ) {
				if( jj_2_5( 2 ) ) {
					;
				} else {
					break label_7;
				}
				jj_consume_token( COMMA );
				atom = VariableInitializer( symbolsTable );
				Hoclc2j.checkExternal( atom );
				ext2 = ( External ) atom;
				ext.javaExpression = ext.javaExpression + ", " + ext2.javaExpression;
			}
			break;
		default:
			jj_la1[20] = jj_gen;
			;
		}
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case COMMA:
			jj_consume_token( COMMA );
			ext.javaExpression = ext.javaExpression + ",";
			break;
		default:
			jj_la1[21] = jj_gen;
			;
		}
		jj_consume_token( RBRACE );
		ext.javaExpression = ext.javaExpression + "}";
		{
			if( true )
				return ext;
		}
		throw new Error( "Missing return statement in function" );
	}


	/*
	 * void MethodDeclaration(int modifiers): {} { // Modifiers already matched in
	 * the caller! [ TypeParameters() ] ResultType() MethodDeclarator() [ "throws"
	 * NameList() ] ( Block() | ";" ) }
	 * 
	 * void MethodDeclarator(): {} { <IDENTIFIER> FormalParameters() ( "[" "]" )*
	 * }
	 * 
	 * void FormalParameters(): {} { "(" [ FormalParameter() ( ","
	 * FormalParameter() )* ] ")" }
	 * 
	 * void FormalParameter(): {} { Modifiers() Type() [ "..." ]
	 * VariableDeclaratorId() }
	 * 
	 * void ConstructorDeclaration(): {} { [ TypeParameters() ] // Modifiers
	 * matched in the caller <IDENTIFIER> FormalParameters() [ "throws" NameList()
	 * ] "{" [ LOOKAHEAD(ExplicitConstructorInvocation())
	 * ExplicitConstructorInvocation() ] ( BlockStatement() )* "}" }
	 * 
	 * void ExplicitConstructorInvocation(): {} { ( <IDENTIFIER> "." )* [
	 * LOOKAHEAD(2) "this" "." ] [ TypeArguments() ] ("this"|"super") Arguments()
	 * ";" }
	 * 
	 * void Initializer(): {} { [ "static" ] Block() }
	 */

	/*
	 * Type, name and expression syntax follows.
	 */
	final public String Type() throws ParseException {
		String u;
		if( jj_2_6( 2 ) ) {
			u = ReferenceType();
			{
				if( true )
					return u;
			}
		} else {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case BOOLEAN:
			case BYTE:
			case CHAR:
			case DOUBLE:
			case FLOAT:
			case INT:
			case LONG:
			case SHORT:
				u = PrimitiveType();
				{
					if( true )
						return u;
				}
				break;
			default:
				jj_la1[22] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String ReferenceType() throws ParseException {
		String u;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case BOOLEAN:
		case BYTE:
		case CHAR:
		case DOUBLE:
		case FLOAT:
		case INT:
		case LONG:
		case SHORT:
			u = PrimitiveType();
			label_8: while( true ) {
				jj_consume_token( LBRACKET );
				jj_consume_token( RBRACKET );
				u = u + "[]";
				if( jj_2_7( 2 ) ) {
					;
				} else {
					break label_8;
				}
			}
			{
				if( true )
					return u;
			}
			break;
		case IDENTIFIER:
			u = ClassOrInterfaceType();
			label_9: while( true ) {
				if( jj_2_8( 2 ) ) {
					;
				} else {
					break label_9;
				}
				jj_consume_token( LBRACKET );
				jj_consume_token( RBRACKET );
				u = u + "[]";
			}
			{
				if( true )
					return u;
			}
			break;
		default:
			jj_la1[23] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String ClassOrInterfaceType() throws ParseException {
		Token t;
		String s, u;
		t = jj_consume_token( IDENTIFIER );
		s = t.image;
		if( jj_2_9( 2 ) ) {
			u = TypeArguments();
			s = s + u;
		} else {
			;
		}
		label_10: while( true ) {
			if( jj_2_10( 2 ) ) {
				;
			} else {
				break label_10;
			}
			jj_consume_token( DOT );
			t = jj_consume_token( IDENTIFIER );
			s = s + "." + t.image;
			if( jj_2_11( 2 ) ) {
				u = TypeArguments();
				s = s + u;
			} else {
				;
			}
		}
		{
			if( true )
				return s;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String TypeArguments() throws ParseException {
		String u, v;
		jj_consume_token( LT );
		u = TypeArgument();
		u = "<" + u;
		label_11: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case COMMA:
				;
				break;
			default:
				jj_la1[24] = jj_gen;
				break label_11;
			}
			jj_consume_token( COMMA );
			v = TypeArgument();
			u = u + ", " + v;
		}
		jj_consume_token( GT );
		u = u + ">";
		{
			if( true )
				return u;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String TypeArgument() throws ParseException {
		String s, u;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case BOOLEAN:
		case BYTE:
		case CHAR:
		case DOUBLE:
		case FLOAT:
		case INT:
		case LONG:
		case SHORT:
		case IDENTIFIER:
			u = ReferenceType();
			{
				if( true )
					return u;
			}
			break;
		case HOOK:
			jj_consume_token( HOOK );
			s = "?";
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case EXTENDS:
			case SUPER:
				u = WildcardBounds();
				s = s + u;
				break;
			default:
				jj_la1[25] = jj_gen;
				;
			}
			{
				if( true )
					return s;
			}
			break;
		default:
			jj_la1[26] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String WildcardBounds() throws ParseException {
		String u;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case EXTENDS:
			jj_consume_token( EXTENDS );
			u = ReferenceType();
			u = " extends " + u;
			{
				if( true )
					return u;
			}
			break;
		case SUPER:
			jj_consume_token( SUPER );
			u = ReferenceType();
			u = " super " + u;
			{
				if( true )
					return u;
			}
			break;
		default:
			jj_la1[27] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String PrimitiveType() throws ParseException {
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case BOOLEAN:
			jj_consume_token( BOOLEAN );
			{
				if( true )
					return new String( "boolean" );
			}
			break;
		case CHAR:
			jj_consume_token( CHAR );
			{
				if( true )
					return new String( "char" );
			}
			break;
		case BYTE:
			jj_consume_token( BYTE );
			{
				if( true )
					return new String( "byte" );
			}
			break;
		case SHORT:
			jj_consume_token( SHORT );
			{
				if( true )
					return new String( "short" );
			}
			break;
		case INT:
			jj_consume_token( INT );
			{
				if( true )
					return new String( "int" );
			}
			break;
		case LONG:
			jj_consume_token( LONG );
			{
				if( true )
					return new String( "long" );
			}
			break;
		case FLOAT:
			jj_consume_token( FLOAT );
			{
				if( true )
					return new String( "float" );
			}
			break;
		case DOUBLE:
			jj_consume_token( DOUBLE );
			{
				if( true )
					return new String( "double" );
			}
			break;
		default:
			jj_la1[28] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public void ResultType() throws ParseException {
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case VOID:
			jj_consume_token( VOID );
			break;
		case BOOLEAN:
		case BYTE:
		case CHAR:
		case DOUBLE:
		case FLOAT:
		case INT:
		case LONG:
		case SHORT:
		case IDENTIFIER:
			Type();
			break;
		default:
			jj_la1[29] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
	}


	final public Atom Name( SymbolsTable symbolsTable ) throws ParseException {
		Token t;
		Atom atom = null;
		External ext = new External();
		t = jj_consume_token( IDENTIFIER );
		if( !Character.isUpperCase( t.image.charAt( 0 ) ) ) {
			// identifier of a variable does not start by an upper letter (cf Java
			// convention)
			Symbols symbols = symbolsTable.lookUp( t.image );
			if( symbols == null ) {
				{
					if( true )
						throw new ParseException( "Unknown identifier: " + t.image );
				}
			} else {
				if( symbols instanceof ReactionRulePat ) {
					// create the ReactionRulePat object and determine if it is a
					// recursive call
					atom = new ReactionRuleVar(
							( ReactionRulePat ) symbols,
							symbolsTable.size() > 1
									&& symbolsTable.get( symbolsTable.size() - 2 ) instanceof ReactionRulePat
									&& ( ( ReactionRulePat ) symbolsTable.get( symbolsTable
											.size() - 2 ) ).varName
											.equals( ( ( ReactionRulePat ) symbols ).varName ) );
				} else if( symbols instanceof MoleculeVarPat ) {
					atom = new MoleculeVar( ( MoleculeVarPat ) symbols );
				} else if( symbols instanceof AtomVarPat ) {
					ext.javaExpression = t.image;
					// ReactionCondition cond = new ReactionCondition();
					// cond.javaExpression = "true";
					// ((AtomVarPat)symbols).setReactionCondition(cond);
					atom = ext;
					ext.addVar( ( AtomVarPat ) symbols );
				}
			}
		} else {
			ext.javaExpression = t.image;
			atom = ext;
		}
		label_12: while( true ) {
			if( jj_2_12( 2 ) ) {
				;
			} else {
				break label_12;
			}
			jj_consume_token( DOT );
			t = jj_consume_token( IDENTIFIER );
			ext.javaExpression = ext.javaExpression + "." + t.image;
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String PackageName() throws ParseException {
		Token t;
		String packName;
		t = jj_consume_token( IDENTIFIER );
		packName = t.image;
		label_13: while( true ) {
			if( jj_2_13( 2 ) ) {
				;
			} else {
				break label_13;
			}
			jj_consume_token( DOT );
			t = jj_consume_token( IDENTIFIER );
			packName = packName + "." + t.image;
		}
		{
			if( true )
				return packName;
		}
		throw new Error( "Missing return statement in function" );
	}


	/*
	 * void NameList(): {} { Name() ( "," Name() )* }
	 */

	/*
	 * Expression syntax follows.
	 */
	final public Atom Expression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		Solution sol;
		ReactionRule reactRule;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case LT:
			/*
			 * No assignment: HOCL as a coordination language [ LOOKAHEAD(2)
			 * AssignmentOperator() Expression() ]
			 */
			sol = Solution( symbolsTable );
			{
				if( true )
					return sol;
			}
			break;
		default:
			jj_la1[30] = jj_gen;
			if( jj_2_14( 2 ) ) {
				// "ident" "=" vs. "ident" "+"
				reactRule = ReactionRule( symbolsTable );
				{
					if( true )
						return reactRule;
				}
			} else {
				switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
				case FALSE:
				case NEW:
				case NULL:
				case TRUE:
				case INTEGER_LITERAL:
				case FLOATING_POINT_LITERAL:
				case CHARACTER_LITERAL:
				case STRING_LITERAL:
				case IDENTIFIER:
				case LPAREN:
				case BANG:
				case TILDE:
				case INCR:
				case DECR:
				case PLUS:
				case MINUS:
					// cf Java grammar: no assignment
					atom = ConditionalExpression( symbolsTable );
					{
						if( true )
							return atom;
					}
					break;
				default:
					jj_la1[31] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
				}
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public void AssignmentOperator() throws ParseException {
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case ASSIGN:
			jj_consume_token( ASSIGN );
			break;
		case 120:
			jj_consume_token( 120 );
			break;
		case 121:
			jj_consume_token( 121 );
			break;
		case 122:
			jj_consume_token( 122 );
			break;
		case 123:
			jj_consume_token( 123 );
			break;
		case 124:
			jj_consume_token( 124 );
			break;
		case 125:
			jj_consume_token( 125 );
			break;
		case 126:
			jj_consume_token( 126 );
			break;
		case 127:
			jj_consume_token( 127 );
			break;
		case 128:
			jj_consume_token( 128 );
			break;
		case 129:
			jj_consume_token( 129 );
			break;
		case 130:
			jj_consume_token( 130 );
			break;
		default:
			jj_la1[32] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
	}


	final public Atom ConditionalExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		External ext, ext2;
		atom = ConditionalOrExpression( symbolsTable );
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case HOOK:
			Hoclc2j.checkExternal( atom );
			ext = ( External ) atom;
			jj_consume_token( HOOK );
			atom2 = Expression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + "? " + ext2.javaExpression;
			ext.addAllVars( ext2 );
			jj_consume_token( COLON );
			atom2 = Expression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + " : " + ext2.javaExpression;
			ext.addAllVars( ext2 );
			break;
		default:
			jj_la1[33] = jj_gen;
			;
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom ConditionalOrExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = ConditionalAndExpression( symbolsTable );
		label_14: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case SC_OR:
				;
				break;
			default:
				jj_la1[34] = jj_gen;
				break label_14;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			jj_consume_token( SC_OR );
			atom2 = ConditionalAndExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + " || " + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom ConditionalAndExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = InclusiveOrExpression( symbolsTable );
		label_15: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case SC_AND:
				;
				break;
			default:
				jj_la1[35] = jj_gen;
				break label_15;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			jj_consume_token( SC_AND );
			atom2 = InclusiveOrExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + " && " + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom InclusiveOrExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = ExclusiveOrExpression( symbolsTable );
		label_16: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case BIT_OR:
				;
				break;
			default:
				jj_la1[36] = jj_gen;
				break label_16;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			jj_consume_token( BIT_OR );
			atom2 = ExclusiveOrExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + " | " + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom ExclusiveOrExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = AndExpression( symbolsTable );
		label_17: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case XOR:
				;
				break;
			default:
				jj_la1[37] = jj_gen;
				break label_17;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			jj_consume_token( XOR );
			atom2 = AndExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + " ^ " + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom AndExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = EqualityExpression( symbolsTable );
		label_18: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case BIT_AND:
				;
				break;
			default:
				jj_la1[38] = jj_gen;
				break label_18;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			jj_consume_token( BIT_AND );
			atom2 = EqualityExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + " & " + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom EqualityExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = InstanceOfExpression( symbolsTable );
		label_19: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case EQ:
			case NE:
				;
				break;
			default:
				jj_la1[39] = jj_gen;
				break label_19;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case EQ:
				jj_consume_token( EQ );
				ext.javaExpression = ext.javaExpression + " == ";
				break;
			case NE:
				jj_consume_token( NE );
				ext.javaExpression = ext.javaExpression + " != ";
				break;
			default:
				jj_la1[40] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			atom2 = InstanceOfExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom InstanceOfExpression( SymbolsTable symbolsTable )
			throws ParseException {
		String u;
		Atom atom;
		atom = RelationalExpression( symbolsTable );
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case INSTANCEOF:
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			jj_consume_token( INSTANCEOF );
			u = Type();
			ext.javaExpression = ext.javaExpression + " instanceof " + u;
			break;
		default:
			jj_la1[41] = jj_gen;
			;
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom RelationalExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		// u = ShiftExpression() // no shifts, conflict with nested solutions eg
		// <3,<5>>,6
		atom = AdditiveExpression( symbolsTable );
		label_20: while( true ) {
			if( jj_2_15( 2 ) ) {
				;
			} else {
				break label_20;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case LT:
				jj_consume_token( LT );
				ext.javaExpression = ext.javaExpression + " < ";
				break;
			case GT:
				jj_consume_token( GT );
				ext.javaExpression = ext.javaExpression + " > ";
				break;
			case LE:
				jj_consume_token( LE );
				ext.javaExpression = ext.javaExpression + " <= ";
				break;
			case GE:
				jj_consume_token( GE );
				ext.javaExpression = ext.javaExpression + " >= ";
				break;
			default:
				jj_la1[42] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			// u = ShiftExpression()
			atom2 = AdditiveExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	/*
	 * String ShiftExpression(): {} { u = AdditiveExpression() ( ( "<<" | u =
	 * RSIGNEDSHIFT() | u = RUNSIGNEDSHIFT() ) u = AdditiveExpression() )* }
	 */
	final public Atom AdditiveExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = MultiplicativeExpression( symbolsTable );
		label_21: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case PLUS:
			case MINUS:
				;
				break;
			default:
				jj_la1[43] = jj_gen;
				break label_21;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case PLUS:
				jj_consume_token( PLUS );
				ext.javaExpression = ext.javaExpression + " + ";
				break;
			case MINUS:
				jj_consume_token( MINUS );
				ext.javaExpression = ext.javaExpression + " - ";
				break;
			default:
				jj_la1[44] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			atom2 = MultiplicativeExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom MultiplicativeExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = UnaryExpression( symbolsTable );
		label_22: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case STAR:
			case SLASH:
			case REM:
				;
				break;
			default:
				jj_la1[45] = jj_gen;
				break label_22;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case STAR:
				jj_consume_token( STAR );
				ext.javaExpression = ext.javaExpression + " * ";
				break;
			case SLASH:
				jj_consume_token( SLASH );
				ext.javaExpression = ext.javaExpression + " / ";
				break;
			case REM:
				jj_consume_token( REM );
				ext.javaExpression = ext.javaExpression + " % ";
				break;
			default:
				jj_la1[46] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			atom2 = UnaryExpression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom UnaryExpression( SymbolsTable symbolsTable )
			throws ParseException {
		String s;
		Atom atom;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case PLUS:
		case MINUS:
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case PLUS:
				jj_consume_token( PLUS );
				s = "+";
				break;
			case MINUS:
				jj_consume_token( MINUS );
				s = "-";
				break;
			default:
				jj_la1[47] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			atom = UnaryExpression( symbolsTable );
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			ext.javaExpression = s + ext.javaExpression;
			{
				if( true )
					return atom;
			}
			break;
		case INCR:
			atom = PreIncrementExpression( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		case DECR:
			atom = PreDecrementExpression( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		case FALSE:
		case NEW:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case LPAREN:
		case BANG:
		case TILDE:
			atom = UnaryExpressionNotPlusMinus( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		default:
			jj_la1[48] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom PreIncrementExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		jj_consume_token( INCR );
		atom = PrimaryExpression( symbolsTable );
		Hoclc2j.checkExternal( atom );
		External ext = ( External ) atom;
		ext.javaExpression = "++" + ext.javaExpression;
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom PreDecrementExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		jj_consume_token( DECR );
		atom = PrimaryExpression( symbolsTable );
		Hoclc2j.checkExternal( atom );
		External ext = ( External ) atom;
		ext.javaExpression = "--" + ext.javaExpression;
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom UnaryExpressionNotPlusMinus( SymbolsTable symbolsTable )
			throws ParseException {
		String s;
		Atom atom;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case BANG:
		case TILDE:
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case TILDE:
				jj_consume_token( TILDE );
				s = "~";
				break;
			case BANG:
				jj_consume_token( BANG );
				s = "!";
				break;
			default:
				jj_la1[49] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			atom = UnaryExpression( symbolsTable );
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			ext.javaExpression = s + ext.javaExpression;
			{
				if( true )
					return atom;
			}
			break;
		default:
			jj_la1[50] = jj_gen;
			if( jj_2_16( 2147483647 ) ) {
				atom = CastExpression( symbolsTable );
				{
					if( true )
						return atom;
				}
			} else {
				switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
				case FALSE:
				case NEW:
				case NULL:
				case TRUE:
				case INTEGER_LITERAL:
				case FLOATING_POINT_LITERAL:
				case CHARACTER_LITERAL:
				case STRING_LITERAL:
				case IDENTIFIER:
				case LPAREN:
					atom = PostfixExpression( symbolsTable );
					{
						if( true )
							return atom;
					}
					break;
				default:
					jj_la1[51] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
				}
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	// This production is to determine lookahead only. The LOOKAHEAD
	// specifications
	// below are not used, but they are there just to indicate that we know about
	// this.
	final public void CastLookahead() throws ParseException {
		if( jj_2_17( 2 ) ) {
			jj_consume_token( LPAREN );
			PrimitiveType();
		} else if( jj_2_18( 2147483647 ) ) {
			jj_consume_token( LPAREN );
			Type();
			jj_consume_token( LBRACKET );
			jj_consume_token( RBRACKET );
		} else {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case LPAREN:
				jj_consume_token( LPAREN );
				Type();
				jj_consume_token( RPAREN );
				switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
				case TILDE:
					jj_consume_token( TILDE );
					break;
				case BANG:
					jj_consume_token( BANG );
					break;
				case LPAREN:
					jj_consume_token( LPAREN );
					break;
				case IDENTIFIER:
					jj_consume_token( IDENTIFIER );
					break;
				case THIS:
					jj_consume_token( THIS );
					break;
				case SUPER:
					jj_consume_token( SUPER );
					break;
				case NEW:
					jj_consume_token( NEW );
					break;
				case FALSE:
				case NULL:
				case TRUE:
				case INTEGER_LITERAL:
				case FLOATING_POINT_LITERAL:
				case CHARACTER_LITERAL:
				case STRING_LITERAL:
					Literal();
					break;
				default:
					jj_la1[52] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
				}
				break;
			default:
				jj_la1[53] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
	}


	final public Atom PostfixExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		External ext;
		atom = PrimaryExpression( symbolsTable );
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case INCR:
		case DECR:
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case INCR:
				jj_consume_token( INCR );
				Hoclc2j.checkExternal( atom );
				ext = ( External ) atom;
				ext.javaExpression = ext.javaExpression + "++";
				break;
			case DECR:
				jj_consume_token( DECR );
				Hoclc2j.checkExternal( atom );
				ext = ( External ) atom;
				ext.javaExpression = ext.javaExpression + "--";
				break;
			default:
				jj_la1[54] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
			break;
		default:
			jj_la1[55] = jj_gen;
			;
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom CastExpression( SymbolsTable symbolsTable )
			throws ParseException {
		String u;
		Atom atom;
		if( jj_2_19( 2147483647 ) ) {
			jj_consume_token( LPAREN );
			u = Type();
			jj_consume_token( RPAREN );
			atom = UnaryExpression( symbolsTable );
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			ext.javaExpression = "(" + u + ")" + ext.javaExpression;
			{
				if( true )
					return atom;
			}
		} else {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case LPAREN:
				jj_consume_token( LPAREN );
				u = Type();
				jj_consume_token( RPAREN );
				atom = UnaryExpressionNotPlusMinus( symbolsTable );
				Hoclc2j.checkExternal( atom );
				External ext = ( External ) atom;
				ext.javaExpression = "(" + u + ")" + ext.javaExpression;
				{
					if( true )
						return atom;
				}
				break;
			default:
				jj_la1[56] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom PrimaryExpression( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = PrimaryPrefix( symbolsTable );
		label_23: while( true ) {
			if( jj_2_20( 2 ) ) {
				;
			} else {
				break label_23;
			}
			Hoclc2j.checkExternal( atom );
			External ext = ( External ) atom;
			atom2 = PrimarySuffix( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return atom;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String MemberSelector() throws ParseException {
		String u;
		Token t;
		jj_consume_token( DOT );
		u = TypeArguments();
		t = jj_consume_token( IDENTIFIER );
		u = "." + u + t.image;
		{
			if( true )
				return u;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom PrimaryPrefix( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom;
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case FALSE:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
			atom = Literal();
			{
				if( true )
					return atom;
			}
			break;
		case LPAREN:
			jj_consume_token( LPAREN );
			atom = Atom( symbolsTable );
			jj_consume_token( RPAREN );
			if( atom instanceof External ) {
				External ext = ( External ) atom;
				ext.javaExpression = "(" + ext.javaExpression + ")";
			}
			{
				if( true )
					return atom;
			}
			break;
		case NEW:
			atom = AllocationExpression( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		case IDENTIFIER:
			atom = Name( symbolsTable );
			{
				if( true )
					return atom;
			}
			break;
		default:
			jj_la1[57] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public Atom PrimarySuffix( SymbolsTable symbolsTable )
			throws ParseException {
		String u;
		Token t;
		Atom atom;
		External ext;
		if( jj_2_21( 2 ) ) {
			jj_consume_token( DOT );
			atom = AllocationExpression( symbolsTable );
			Hoclc2j.checkExternal( atom );
			ext = ( External ) atom;
			ext.javaExpression = "." + ext.javaExpression;
			{
				if( true )
					return atom;
			}
		} else if( jj_2_22( 3 ) ) {
			u = MemberSelector();
			ext = new External();
			ext.javaExpression = u;
			{
				if( true )
					return ext;
			}
		} else {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case LBRACKET:
				jj_consume_token( LBRACKET );
				atom = Expression( symbolsTable );
				Hoclc2j.checkExternal( atom );
				ext = ( External ) atom;
				jj_consume_token( RBRACKET );
				ext.javaExpression = "[" + ext.javaExpression + "]";
				{
					if( true )
						return atom;
				}
				break;
			case DOT:
				jj_consume_token( DOT );
				t = jj_consume_token( IDENTIFIER );
				ext = new External();
				ext.javaExpression = "." + t.image;
				{
					if( true )
						return ext;
				}
				break;
			case LPAREN:
				atom = Arguments( symbolsTable );
				{
					if( true )
						return atom;
				}
				break;
			default:
				jj_la1[58] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public External Literal() throws ParseException {
		Token t;
		String u;
		External ext = new External();
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case INTEGER_LITERAL:
			t = jj_consume_token( INTEGER_LITERAL );
			ext.javaExpression = t.image;
			ext.javaType = "Integer";
			break;
		case FLOATING_POINT_LITERAL:
			t = jj_consume_token( FLOATING_POINT_LITERAL );
			ext.javaExpression = t.image;
			ext.javaType = "Float";
			break;
		case CHARACTER_LITERAL:
			t = jj_consume_token( CHARACTER_LITERAL );
			ext.javaExpression = t.image;
			ext.javaType = "Character";
			break;
		case STRING_LITERAL:
			t = jj_consume_token( STRING_LITERAL );
			ext.javaExpression = t.image;
			ext.javaType = "String";
			break;
		case FALSE:
		case TRUE:
			u = BooleanLiteral();
			ext.javaExpression = u;
			ext.javaType = "Boolean";
			break;
		case NULL:
			NullLiteral();
			ext.javaExpression = "null";
			break;
		default:
			jj_la1[59] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		{
			if( true )
				return ext;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public String BooleanLiteral() throws ParseException {
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case TRUE:
			jj_consume_token( TRUE );
			{
				if( true )
					return "true";
			}
			break;
		case FALSE:
			jj_consume_token( FALSE );
			{
				if( true )
					return "false";
			}
			break;
		default:
			jj_la1[60] = jj_gen;
			jj_consume_token( -1 );
			throw new ParseException();
		}
		throw new Error( "Missing return statement in function" );
	}


	final public void NullLiteral() throws ParseException {
		jj_consume_token( NULL );
	}


	final public External Arguments( SymbolsTable symbolsTable )
			throws ParseException {
		External ext = null;
		jj_consume_token( LPAREN );
		switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
		case FALSE:
		case NEW:
		case NULL:
		case TRUE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case CHARACTER_LITERAL:
		case STRING_LITERAL:
		case REPLACE:
		case REPLACE_ONE:
		case IDENTIFIER:
		case LPAREN:
		case LT:
		case BANG:
		case TILDE:
		case INCR:
		case DECR:
		case PLUS:
		case MINUS:
			ext = ArgumentList( symbolsTable );
			break;
		default:
			jj_la1[61] = jj_gen;
			;
		}
		jj_consume_token( RPAREN );
		if( ext != null ) {
			ext.javaExpression = "(" + ext.javaExpression + ")";
			{
				if( true )
					return ext;
			}
		} else {
			ext = new External();
			ext.javaExpression = "()";
			{
				if( true )
					return ext;
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final public External ArgumentList( SymbolsTable symbolsTable )
			throws ParseException {
		Atom atom, atom2;
		atom = Expression( symbolsTable );
		Hoclc2j.checkExternal( atom );
		External ext = ( External ) atom;
		label_24: while( true ) {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case COMMA:
				;
				break;
			default:
				jj_la1[62] = jj_gen;
				break label_24;
			}
			jj_consume_token( COMMA );
			atom2 = Expression( symbolsTable );
			Hoclc2j.checkExternal( atom2 );
			External ext2 = ( External ) atom2;
			ext.javaExpression = ext.javaExpression + ", " + ext2.javaExpression;
			ext.addAllVars( ext2 );
		}
		{
			if( true )
				return ext;
		}
		throw new Error( "Missing return statement in function" );
	}


	final public External AllocationExpression( SymbolsTable symbolsTable )
			throws ParseException {
		String u, v;
		External ext;
		if( jj_2_23( 2 ) ) {
			jj_consume_token( NEW );
			u = PrimitiveType();
			ext = ArrayDimsAndInits( symbolsTable );
			ext.javaExpression = "new " + u + ext.javaExpression;
			{
				if( true )
					return ext;
			}
		} else {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case NEW:
				jj_consume_token( NEW );
				u = ClassOrInterfaceType();
				u = "new " + u;
				switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
				case LT:
					v = TypeArguments();
					u = u + v;
					break;
				default:
					jj_la1[63] = jj_gen;
					;
				}
				switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
				case LBRACKET:
					ext = ArrayDimsAndInits( symbolsTable );
					break;
				case LPAREN:
					ext = Arguments( symbolsTable );
					break;
				default:
					jj_la1[64] = jj_gen;
					jj_consume_token( -1 );
					throw new ParseException();
				}
				break;
			default:
				jj_la1[65] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		ext.javaExpression = u + ext.javaExpression;
		{
			if( true )
				return ext;
		}
		throw new Error( "Missing return statement in function" );
	}


	/*
	 * The third LOOKAHEAD specification below is to parse to PrimarySuffix if
	 * there is an expression between the "[...]".
	 */
	final public External ArrayDimsAndInits( SymbolsTable symbolsTable )
			throws ParseException {
		External ext = new External(), ext2;
		Atom atom;
		if( jj_2_26( 2 ) ) {
			label_25: while( true ) {
				jj_consume_token( LBRACKET );
				atom = Expression( symbolsTable );
				Hoclc2j.checkExternal( atom );
				ext2 = ( External ) atom;
				jj_consume_token( RBRACKET );
				ext.javaExpression = ext.javaExpression + "[" + ext2.javaExpression
						+ "]";
				ext.addAllVars( ext2 );
				if( jj_2_24( 2 ) ) {
					;
				} else {
					break label_25;
				}
			}
			label_26: while( true ) {
				if( jj_2_25( 2 ) ) {
					;
				} else {
					break label_26;
				}
				jj_consume_token( LBRACKET );
				jj_consume_token( RBRACKET );
				ext.javaExpression = ext.javaExpression + "[]";
			}
			{
				if( true )
					return ext;
			}
		} else {
			switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
			case LBRACKET:
				label_27: while( true ) {
					jj_consume_token( LBRACKET );
					jj_consume_token( RBRACKET );
					ext.javaExpression = ext.javaExpression + "[]";
					switch( ( jj_ntk == -1 ) ? jj_ntk() : jj_ntk ) {
					case LBRACKET:
						;
						break;
					default:
						jj_la1[66] = jj_gen;
						break label_27;
					}
				}
				ext2 = ArrayInitializer( symbolsTable );
				ext.javaExpression = ext.javaExpression + ext2.javaExpression;
				ext.addAllVars( ext2 );
				{
					if( true )
						return ext;
				}
				break;
			default:
				jj_la1[67] = jj_gen;
				jj_consume_token( -1 );
				throw new ParseException();
			}
		}
		throw new Error( "Missing return statement in function" );
	}


	final private boolean jj_2_1( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_1();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 0, xla );
		}
	}


	final private boolean jj_2_2( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_2();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 1, xla );
		}
	}


	final private boolean jj_2_3( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_3();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 2, xla );
		}
	}


	final private boolean jj_2_4( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_4();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 3, xla );
		}
	}


	final private boolean jj_2_5( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_5();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 4, xla );
		}
	}


	final private boolean jj_2_6( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_6();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 5, xla );
		}
	}


	final private boolean jj_2_7( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_7();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 6, xla );
		}
	}


	final private boolean jj_2_8( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_8();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 7, xla );
		}
	}


	final private boolean jj_2_9( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_9();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 8, xla );
		}
	}


	final private boolean jj_2_10( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_10();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 9, xla );
		}
	}


	final private boolean jj_2_11( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_11();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 10, xla );
		}
	}


	final private boolean jj_2_12( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_12();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 11, xla );
		}
	}


	final private boolean jj_2_13( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_13();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 12, xla );
		}
	}


	final private boolean jj_2_14( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_14();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 13, xla );
		}
	}


	final private boolean jj_2_15( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_15();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 14, xla );
		}
	}


	final private boolean jj_2_16( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_16();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 15, xla );
		}
	}


	final private boolean jj_2_17( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_17();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 16, xla );
		}
	}


	final private boolean jj_2_18( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_18();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 17, xla );
		}
	}


	final private boolean jj_2_19( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_19();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 18, xla );
		}
	}


	final private boolean jj_2_20( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_20();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 19, xla );
		}
	}


	final private boolean jj_2_21( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_21();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 20, xla );
		}
	}


	final private boolean jj_2_22( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_22();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 21, xla );
		}
	}


	final private boolean jj_2_23( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_23();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 22, xla );
		}
	}


	final private boolean jj_2_24( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_24();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 23, xla );
		}
	}


	final private boolean jj_2_25( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_25();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 24, xla );
		}
	}


	final private boolean jj_2_26( int xla ) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_26();
		} catch( LookaheadSuccess ls ) {
			return true;
		} finally {
			jj_save( 25, xla );
		}
	}


	final private boolean jj_3_2() {
		if( jj_scan_token( COLON ) )
			return true;
		if( jj_3R_29() )
			return true;
		return false;
	}


	final private boolean jj_3R_54() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3_21() ) {
			jj_scanpos = xsp;
			if( jj_3_22() ) {
				jj_scanpos = xsp;
				if( jj_3R_78() ) {
					jj_scanpos = xsp;
					if( jj_3R_79() ) {
						jj_scanpos = xsp;
						if( jj_3R_80() )
							return true;
					}
				}
			}
		}
		return false;
	}


	final private boolean jj_3_21() {
		if( jj_scan_token( DOT ) )
			return true;
		if( jj_3R_55() )
			return true;
		return false;
	}


	final private boolean jj_3R_28() {
		if( jj_3R_29() )
			return true;
		return false;
	}


	final private boolean jj_3R_95() {
		if( jj_3R_104() )
			return true;
		return false;
	}


	final private boolean jj_3_1() {
		if( jj_scan_token( COMMA ) )
			return true;
		if( jj_3R_28() )
			return true;
		return false;
	}


	final private boolean jj_3R_147() {
		if( jj_3R_150() )
			return true;
		return false;
	}


	final private boolean jj_3R_146() {
		if( jj_3R_55() )
			return true;
		return false;
	}


	final private boolean jj_3R_83() {
		if( jj_3R_95() )
			return true;
		return false;
	}


	final private boolean jj_3R_145() {
		if( jj_scan_token( LPAREN ) )
			return true;
		return false;
	}


	final private boolean jj_3R_82() {
		if( jj_3R_94() )
			return true;
		return false;
	}


	final private boolean jj_3R_58() {
		if( jj_3R_83() )
			return true;
		return false;
	}


	final private boolean jj_3R_92() {
		if( jj_3R_102() )
			return true;
		return false;
	}


	final private boolean jj_3_14() {
		if( jj_3R_45() )
			return true;
		return false;
	}


	final private boolean jj_3R_57() {
		if( jj_3R_82() )
			return true;
		return false;
	}


	final private boolean jj_3R_29() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_57() ) {
			jj_scanpos = xsp;
			if( jj_3_14() ) {
				jj_scanpos = xsp;
				if( jj_3R_58() )
					return true;
			}
		}
		return false;
	}


	final private boolean jj_3R_142() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_144() ) {
			jj_scanpos = xsp;
			if( jj_3R_145() ) {
				jj_scanpos = xsp;
				if( jj_3R_146() ) {
					jj_scanpos = xsp;
					if( jj_3R_147() )
						return true;
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_144() {
		if( jj_3R_102() )
			return true;
		return false;
	}


	final private boolean jj_3R_56() {
		if( jj_scan_token( DOT ) )
			return true;
		if( jj_3R_44() )
			return true;
		return false;
	}


	final private boolean jj_3R_30() {
		if( jj_scan_token( ASSIGN ) )
			return true;
		return false;
	}


	final private boolean jj_3_20() {
		if( jj_3R_54() )
			return true;
		return false;
	}


	final private boolean jj_3R_94() {
		if( jj_scan_token( LT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_139() {
		if( jj_3R_142() )
			return true;
		return false;
	}


	final private boolean jj_3_13() {
		if( jj_scan_token( DOT ) )
			return true;
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		return false;
	}


	final private boolean jj_3_19() {
		if( jj_scan_token( LPAREN ) )
			return true;
		if( jj_3R_52() )
			return true;
		return false;
	}


	final private boolean jj_3R_138() {
		if( jj_scan_token( LPAREN ) )
			return true;
		return false;
	}


	final private boolean jj_3R_132() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_137() ) {
			jj_scanpos = xsp;
			if( jj_3R_138() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_137() {
		if( jj_scan_token( LPAREN ) )
			return true;
		return false;
	}


	final private boolean jj_3_12() {
		if( jj_scan_token( DOT ) )
			return true;
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		return false;
	}


	final private boolean jj_3_18() {
		if( jj_scan_token( LPAREN ) )
			return true;
		if( jj_3R_53() )
			return true;
		if( jj_scan_token( LBRACKET ) )
			return true;
		return false;
	}


	final private boolean jj_3R_133() {
		if( jj_3R_139() )
			return true;
		return false;
	}


	final private boolean jj_3R_68() {
		if( jj_scan_token( LPAREN ) )
			return true;
		if( jj_3R_53() )
			return true;
		if( jj_scan_token( RPAREN ) )
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if( jj_scan_token( 100 ) ) {
			jj_scanpos = xsp;
			if( jj_scan_token( 99 ) ) {
				jj_scanpos = xsp;
				if( jj_scan_token( 87 ) ) {
					jj_scanpos = xsp;
					if( jj_scan_token( 84 ) ) {
						jj_scanpos = xsp;
						if( jj_scan_token( 56 ) ) {
							jj_scanpos = xsp;
							if( jj_scan_token( 53 ) ) {
								jj_scanpos = xsp;
								if( jj_scan_token( 43 ) ) {
									jj_scanpos = xsp;
									if( jj_3R_92() )
										return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_67() {
		if( jj_scan_token( LPAREN ) )
			return true;
		if( jj_3R_53() )
			return true;
		if( jj_scan_token( LBRACKET ) )
			return true;
		if( jj_scan_token( RBRACKET ) )
			return true;
		return false;
	}


	final private boolean jj_3R_51() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3_17() ) {
			jj_scanpos = xsp;
			if( jj_3R_67() ) {
				jj_scanpos = xsp;
				if( jj_3R_68() )
					return true;
			}
		}
		return false;
	}


	final private boolean jj_3_17() {
		if( jj_scan_token( LPAREN ) )
			return true;
		if( jj_3R_52() )
			return true;
		return false;
	}


	final private boolean jj_3_16() {
		if( jj_3R_51() )
			return true;
		return false;
	}


	final private boolean jj_3R_150() {
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		return false;
	}


	final private boolean jj_3R_123() {
		if( jj_3R_133() )
			return true;
		return false;
	}


	final private boolean jj_3R_41() {
		if( jj_scan_token( STRICTFP ) )
			return true;
		return false;
	}


	final private boolean jj_3R_122() {
		if( jj_3R_132() )
			return true;
		return false;
	}


	final private boolean jj_3R_40() {
		if( jj_scan_token( VOLATILE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_131() {
		if( jj_scan_token( BANG ) )
			return true;
		return false;
	}


	final private boolean jj_3R_39() {
		if( jj_scan_token( TRANSIENT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_130() {
		if( jj_scan_token( TILDE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_38() {
		if( jj_scan_token( NATIVE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_37() {
		if( jj_scan_token( SYNCHRONIZED ) )
			return true;
		return false;
	}


	final private boolean jj_3R_111() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_121() ) {
			jj_scanpos = xsp;
			if( jj_3R_122() ) {
				jj_scanpos = xsp;
				if( jj_3R_123() )
					return true;
			}
		}
		return false;
	}


	final private boolean jj_3R_121() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_130() ) {
			jj_scanpos = xsp;
			if( jj_3R_131() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_36() {
		if( jj_scan_token( ABSTRACT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_35() {
		if( jj_scan_token( FINAL ) )
			return true;
		return false;
	}


	final private boolean jj_3R_76() {
		if( jj_scan_token( DOUBLE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_34() {
		if( jj_scan_token( PRIVATE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_75() {
		if( jj_scan_token( FLOAT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_33() {
		if( jj_scan_token( PROTECTED ) )
			return true;
		return false;
	}


	final private boolean jj_3R_74() {
		if( jj_scan_token( LONG ) )
			return true;
		return false;
	}


	final private boolean jj_3R_32() {
		if( jj_scan_token( STATIC ) )
			return true;
		return false;
	}


	final private boolean jj_3R_73() {
		if( jj_scan_token( INT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_31() {
		if( jj_scan_token( PUBLIC ) )
			return true;
		return false;
	}


	final private boolean jj_3R_72() {
		if( jj_scan_token( SHORT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_110() {
		if( jj_scan_token( DECR ) )
			return true;
		return false;
	}


	final private boolean jj_3R_71() {
		if( jj_scan_token( BYTE ) )
			return true;
		return false;
	}


	final private boolean jj_3_4() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_31() ) {
			jj_scanpos = xsp;
			if( jj_3R_32() ) {
				jj_scanpos = xsp;
				if( jj_3R_33() ) {
					jj_scanpos = xsp;
					if( jj_3R_34() ) {
						jj_scanpos = xsp;
						if( jj_3R_35() ) {
							jj_scanpos = xsp;
							if( jj_3R_36() ) {
								jj_scanpos = xsp;
								if( jj_3R_37() ) {
									jj_scanpos = xsp;
									if( jj_3R_38() ) {
										jj_scanpos = xsp;
										if( jj_3R_39() ) {
											jj_scanpos = xsp;
											if( jj_3R_40() ) {
												jj_scanpos = xsp;
												if( jj_3R_41() )
													return true;
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_70() {
		if( jj_scan_token( CHAR ) )
			return true;
		return false;
	}


	final private boolean jj_3R_69() {
		if( jj_scan_token( BOOLEAN ) )
			return true;
		return false;
	}


	final private boolean jj_3R_52() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_69() ) {
			jj_scanpos = xsp;
			if( jj_3R_70() ) {
				jj_scanpos = xsp;
				if( jj_3R_71() ) {
					jj_scanpos = xsp;
					if( jj_3R_72() ) {
						jj_scanpos = xsp;
						if( jj_3R_73() ) {
							jj_scanpos = xsp;
							if( jj_3R_74() ) {
								jj_scanpos = xsp;
								if( jj_3R_75() ) {
									jj_scanpos = xsp;
									if( jj_3R_76() )
										return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_109() {
		if( jj_scan_token( INCR ) )
			return true;
		return false;
	}


	final private boolean jj_3R_153() {
		if( jj_scan_token( SUPER ) )
			return true;
		if( jj_3R_43() )
			return true;
		return false;
	}


	final private boolean jj_3R_152() {
		if( jj_scan_token( EXTENDS ) )
			return true;
		if( jj_3R_43() )
			return true;
		return false;
	}


	final private boolean jj_3R_151() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_152() ) {
			jj_scanpos = xsp;
			if( jj_3R_153() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_101() {
		if( jj_3R_111() )
			return true;
		return false;
	}


	final private boolean jj_3R_100() {
		if( jj_3R_110() )
			return true;
		return false;
	}


	final private boolean jj_3R_99() {
		if( jj_3R_109() )
			return true;
		return false;
	}


	final private boolean jj_3R_148() {
		if( jj_3R_151() )
			return true;
		return false;
	}


	final private boolean jj_3R_108() {
		if( jj_scan_token( MINUS ) )
			return true;
		return false;
	}


	final private boolean jj_3R_107() {
		if( jj_scan_token( PLUS ) )
			return true;
		return false;
	}


	final private boolean jj_3R_87() {
		if( jj_scan_token( HOOK ) )
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_148() )
			jj_scanpos = xsp;
		return false;
	}


	final private boolean jj_3R_63() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_86() ) {
			jj_scanpos = xsp;
			if( jj_3R_87() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_86() {
		if( jj_3R_43() )
			return true;
		return false;
	}


	final private boolean jj_3R_91() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_98() ) {
			jj_scanpos = xsp;
			if( jj_3R_99() ) {
				jj_scanpos = xsp;
				if( jj_3R_100() ) {
					jj_scanpos = xsp;
					if( jj_3R_101() )
						return true;
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_98() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_107() ) {
			jj_scanpos = xsp;
			if( jj_3R_108() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_140() {
		if( jj_scan_token( COMMA ) )
			return true;
		if( jj_3R_63() )
			return true;
		return false;
	}


	final private boolean jj_3R_44() {
		if( jj_scan_token( LT ) )
			return true;
		if( jj_3R_63() )
			return true;
		Token xsp;
		while( true ) {
			xsp = jj_scanpos;
			if( jj_3R_140() ) {
				jj_scanpos = xsp;
				break;
			}
		}
		if( jj_scan_token( GT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_66() {
		if( jj_3R_91() )
			return true;
		return false;
	}


	final private boolean jj_3_11() {
		if( jj_3R_44() )
			return true;
		return false;
	}


	final private boolean jj_3_10() {
		if( jj_scan_token( DOT ) )
			return true;
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3_11() )
			jj_scanpos = xsp;
		return false;
	}


	final private boolean jj_3_9() {
		if( jj_3R_44() )
			return true;
		return false;
	}


	final private boolean jj_3R_129() {
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		return false;
	}


	final private boolean jj_3R_128() {
		if( jj_3R_102() )
			return true;
		return false;
	}


	final private boolean jj_3R_85() {
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3_9() )
			jj_scanpos = xsp;
		while( true ) {
			xsp = jj_scanpos;
			if( jj_3_10() ) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}


	final private boolean jj_3R_127() {
		if( jj_3R_94() )
			return true;
		return false;
	}


	final private boolean jj_3R_50() {
		if( jj_3R_66() )
			return true;
		return false;
	}


	final private boolean jj_3_3() {
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		if( jj_3R_30() )
			return true;
		return false;
	}


	final private boolean jj_3_8() {
		if( jj_scan_token( LBRACKET ) )
			return true;
		if( jj_scan_token( RBRACKET ) )
			return true;
		return false;
	}


	final private boolean jj_3_25() {
		if( jj_scan_token( LBRACKET ) )
			return true;
		if( jj_scan_token( RBRACKET ) )
			return true;
		return false;
	}


	final private boolean jj_3R_120() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_126() ) {
			jj_scanpos = xsp;
			if( jj_3_3() ) {
				jj_scanpos = xsp;
				if( jj_3R_127() ) {
					jj_scanpos = xsp;
					if( jj_3R_128() ) {
						jj_scanpos = xsp;
						if( jj_3R_129() )
							return true;
					}
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_126() {
		if( jj_scan_token( LPAREN ) )
			return true;
		return false;
	}


	final private boolean jj_3R_62() {
		if( jj_3R_85() )
			return true;
		Token xsp;
		while( true ) {
			xsp = jj_scanpos;
			if( jj_3_8() ) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}


	final private boolean jj_3_24() {
		if( jj_scan_token( LBRACKET ) )
			return true;
		if( jj_3R_29() )
			return true;
		return false;
	}


	final private boolean jj_3_7() {
		if( jj_scan_token( LBRACKET ) )
			return true;
		if( jj_scan_token( RBRACKET ) )
			return true;
		return false;
	}


	final private boolean jj_3R_106() {
		if( jj_scan_token( HOOK ) )
			return true;
		return false;
	}


	final private boolean jj_3_26() {
		Token xsp;
		if( jj_3_24() )
			return true;
		while( true ) {
			xsp = jj_scanpos;
			if( jj_3_24() ) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}


	final private boolean jj_3R_61() {
		if( jj_3R_52() )
			return true;
		Token xsp;
		if( jj_3_7() )
			return true;
		while( true ) {
			xsp = jj_scanpos;
			if( jj_3_7() ) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}


	final private boolean jj_3R_43() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_61() ) {
			jj_scanpos = xsp;
			if( jj_3R_62() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_77() {
		if( jj_3R_52() )
			return true;
		return false;
	}


	final private boolean jj_3R_49() {
		if( jj_scan_token( GE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_53() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3_6() ) {
			jj_scanpos = xsp;
			if( jj_3R_77() )
				return true;
		}
		return false;
	}


	final private boolean jj_3_6() {
		if( jj_3R_43() )
			return true;
		return false;
	}


	final private boolean jj_3R_48() {
		if( jj_scan_token( LE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_47() {
		if( jj_scan_token( GT ) )
			return true;
		return false;
	}


	final private boolean jj_3R_46() {
		if( jj_scan_token( LT ) )
			return true;
		return false;
	}


	final private boolean jj_3_15() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_46() ) {
			jj_scanpos = xsp;
			if( jj_3R_47() ) {
				jj_scanpos = xsp;
				if( jj_3R_48() ) {
					jj_scanpos = xsp;
					if( jj_3R_49() )
						return true;
				}
			}
		}
		if( jj_3R_50() )
			return true;
		return false;
	}


	final private boolean jj_3R_149() {
		if( jj_3R_50() )
			return true;
		return false;
	}


	final private boolean jj_3R_105() {
		if( jj_3R_120() )
			return true;
		return false;
	}


	final private boolean jj_3R_81() {
		if( jj_scan_token( NEW ) )
			return true;
		return false;
	}


	final private boolean jj_3_23() {
		if( jj_scan_token( NEW ) )
			return true;
		if( jj_3R_52() )
			return true;
		return false;
	}


	final private boolean jj_3R_55() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3_23() ) {
			jj_scanpos = xsp;
			if( jj_3R_81() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_97() {
		if( jj_3R_106() )
			return true;
		return false;
	}


	final private boolean jj_3R_143() {
		if( jj_3R_149() )
			return true;
		return false;
	}


	final private boolean jj_3R_96() {
		if( jj_3R_105() )
			return true;
		return false;
	}


	final private boolean jj_3R_90() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_96() ) {
			jj_scanpos = xsp;
			if( jj_3R_97() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_118() {
		if( jj_3R_29() )
			return true;
		return false;
	}


	final private boolean jj_3R_141() {
		if( jj_3R_143() )
			return true;
		return false;
	}


	final private boolean jj_3R_89() {
		if( jj_scan_token( REPLACE_ONE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_88() {
		if( jj_scan_token( REPLACE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_103() {
		if( jj_3R_118() )
			return true;
		return false;
	}


	final private boolean jj_3R_65() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_88() ) {
			jj_scanpos = xsp;
			if( jj_3R_89() )
				return true;
		}
		if( jj_3R_90() )
			return true;
		return false;
	}


	final private boolean jj_3R_93() {
		if( jj_scan_token( LPAREN ) )
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_103() )
			jj_scanpos = xsp;
		if( jj_scan_token( RPAREN ) )
			return true;
		return false;
	}


	final private boolean jj_3R_136() {
		if( jj_3R_141() )
			return true;
		return false;
	}


	final private boolean jj_3R_135() {
		if( jj_scan_token( FALSE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_64() {
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		if( jj_3R_30() )
			return true;
		return false;
	}


	final private boolean jj_3R_124() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_134() ) {
			jj_scanpos = xsp;
			if( jj_3R_135() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_134() {
		if( jj_scan_token( TRUE ) )
			return true;
		return false;
	}


	final private boolean jj_3_5() {
		if( jj_scan_token( COMMA ) )
			return true;
		if( jj_3R_42() )
			return true;
		return false;
	}


	final private boolean jj_3R_45() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_64() )
			jj_scanpos = xsp;
		if( jj_3R_65() )
			return true;
		return false;
	}


	final private boolean jj_3R_125() {
		if( jj_3R_136() )
			return true;
		return false;
	}


	final private boolean jj_3R_117() {
		if( jj_scan_token( 44 ) )
			return true;
		return false;
	}


	final private boolean jj_3R_116() {
		if( jj_3R_124() )
			return true;
		return false;
	}


	final private boolean jj_3R_84() {
		if( jj_scan_token( LBRACE ) )
			return true;
		return false;
	}


	final private boolean jj_3R_115() {
		if( jj_scan_token( STRING_LITERAL ) )
			return true;
		return false;
	}


	final private boolean jj_3R_114() {
		if( jj_scan_token( CHARACTER_LITERAL ) )
			return true;
		return false;
	}


	final private boolean jj_3R_113() {
		if( jj_scan_token( FLOATING_POINT_LITERAL ) )
			return true;
		return false;
	}


	final private boolean jj_3R_60() {
		if( jj_3R_29() )
			return true;
		return false;
	}


	final private boolean jj_3R_112() {
		if( jj_scan_token( INTEGER_LITERAL ) )
			return true;
		return false;
	}


	final private boolean jj_3R_59() {
		if( jj_3R_84() )
			return true;
		return false;
	}


	final private boolean jj_3R_42() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_59() ) {
			jj_scanpos = xsp;
			if( jj_3R_60() )
				return true;
		}
		return false;
	}


	final private boolean jj_3R_119() {
		if( jj_3R_125() )
			return true;
		return false;
	}


	final private boolean jj_3R_102() {
		Token xsp;
		xsp = jj_scanpos;
		if( jj_3R_112() ) {
			jj_scanpos = xsp;
			if( jj_3R_113() ) {
				jj_scanpos = xsp;
				if( jj_3R_114() ) {
					jj_scanpos = xsp;
					if( jj_3R_115() ) {
						jj_scanpos = xsp;
						if( jj_3R_116() ) {
							jj_scanpos = xsp;
							if( jj_3R_117() )
								return true;
						}
					}
				}
			}
		}
		return false;
	}


	final private boolean jj_3R_80() {
		if( jj_3R_93() )
			return true;
		return false;
	}


	final private boolean jj_3R_79() {
		if( jj_scan_token( DOT ) )
			return true;
		if( jj_scan_token( IDENTIFIER ) )
			return true;
		return false;
	}


	final private boolean jj_3R_104() {
		if( jj_3R_119() )
			return true;
		return false;
	}


	final private boolean jj_3R_78() {
		if( jj_scan_token( LBRACKET ) )
			return true;
		if( jj_3R_29() )
			return true;
		return false;
	}


	final private boolean jj_3_22() {
		if( jj_3R_56() )
			return true;
		return false;
	}

	public HoclParserTokenManager token_source;

	JavaCharStream jj_input_stream;

	public Token token, jj_nt;

	private int jj_ntk;

	private Token jj_scanpos, jj_lastpos;

	private int jj_la;

	public boolean lookingAhead = false;

	private boolean jj_semLA;

	private int jj_gen;

	final private int[] jj_la1 = new int[68];

	static private int[] jj_la1_0;

	static private int[] jj_la1_1;

	static private int[] jj_la1_2;

	static private int[] jj_la1_3;

	static private int[] jj_la1_4;
	static {
		jj_la1_0();
		jj_la1_1();
		jj_la1_2();
		jj_la1_3();
		jj_la1_4();
	}


	private static void jj_la1_0() {
		jj_la1_0 = new int[] { 0x40001000, 0x0, 0x0, 0x0, 0x20000000, 0x20000000,
				0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x20000000, 0x0, 0x0, 0x20000000,
				0x0, 0x0, 0x40001000, 0x20000000, 0x20000000, 0x0, 0x2094000,
				0x2094000, 0x0, 0x10000000, 0x2094000, 0x10000000, 0x2094000,
				0x2094000, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0,
				0x20000000, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0,
				0x20000000, 0x20000000, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, };
	}


	private static void jj_la1_1() {
		jj_la1_1 = new int[] { 0x8899e400, 0x20, 0x0, 0x0, 0x10001800, 0x10001800,
				0x0, 0x0, 0x0, 0x8, 0x10001000, 0x0, 0x10001000, 0x0, 0x0, 0x10001000,
				0x80000, 0x0, 0x8899c400, 0x10001800, 0x10001800, 0x0, 0x40281,
				0x40281, 0x0, 0x200000, 0x40281, 0x200000, 0x40281, 0x40040281, 0x0,
				0x10001800, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x10001800, 0x0, 0x0, 0x10001800, 0x11201800,
				0x0, 0x0, 0x0, 0x0, 0x10001800, 0x0, 0x10001000, 0x10000000,
				0x10001800, 0x0, 0x0, 0x0, 0x800, 0x0, 0x0, };
	}


	private static void jj_la1_2() {
		jj_la1_2 = new int[] { 0x0, 0x0, 0x40000, 0x8000, 0x90dc22, 0x90dc22,
				0x40000, 0x100000, 0x5000, 0x0, 0x900c22, 0x40000000, 0x900c22, 0x0,
				0x800000, 0x100c22, 0x0, 0x80000000, 0x0, 0x2905c22, 0x2905c22,
				0x40000000, 0x0, 0x100000, 0x40000000, 0x0, 0x100000, 0x0, 0x0,
				0x100000, 0x0, 0x900c22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x900c22, 0x0, 0x0, 0x900c22,
				0x900c22, 0x800000, 0x0, 0x0, 0x800000, 0x900c22, 0x88800000, 0xc22,
				0x0, 0x905c22, 0x40000000, 0x0, 0x8800000, 0x0, 0x8000000, 0x8000000, };
	}


	private static void jj_la1_3() {
		jj_la1_3 = new int[] { 0x0, 0x0, 0x0, 0x4, 0x81e01c, 0x1e01c, 0x0, 0x0,
				0x0, 0x0, 0x24, 0x0, 0x24, 0x40, 0x0, 0x4, 0x0, 0x0, 0x0, 0x1e01c,
				0x1e01c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x4, 0x1e018,
				0xff000002, 0x20, 0x800, 0x1000, 0x100000, 0x200000, 0x80000, 0x480,
				0x480, 0x0, 0x800304, 0x18000, 0x18000, 0x460000, 0x460000, 0x18000,
				0x1e018, 0x18, 0x18, 0x0, 0x18, 0x0, 0x6000, 0x6000, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x1e01c, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, };
	}


	private static void jj_la1_4() {
		jj_la1_4 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[26];

	private boolean jj_rescan = false;

	private int jj_gc = 0;


	public HoclParser( java.io.InputStream stream ) {
		this( stream, null );
	}


	public HoclParser( java.io.InputStream stream, String encoding ) {
		try {
			jj_input_stream = new JavaCharStream( stream, encoding, 1, 1 );
		} catch( java.io.UnsupportedEncodingException e ) {
			throw new RuntimeException( e );
		}
		token_source = new HoclParserTokenManager( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 68; i++ )
			jj_la1[i] = -1;
		for( int i = 0; i < jj_2_rtns.length; i++ )
			jj_2_rtns[i] = new JJCalls();
	}


	public void ReInit( java.io.InputStream stream ) {
		ReInit( stream, null );
	}


	public void ReInit( java.io.InputStream stream, String encoding ) {
		try {
			jj_input_stream.ReInit( stream, encoding, 1, 1 );
		} catch( java.io.UnsupportedEncodingException e ) {
			throw new RuntimeException( e );
		}
		token_source.ReInit( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 68; i++ )
			jj_la1[i] = -1;
		for( int i = 0; i < jj_2_rtns.length; i++ )
			jj_2_rtns[i] = new JJCalls();
	}


	public HoclParser( java.io.Reader stream ) {
		jj_input_stream = new JavaCharStream( stream, 1, 1 );
		token_source = new HoclParserTokenManager( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 68; i++ )
			jj_la1[i] = -1;
		for( int i = 0; i < jj_2_rtns.length; i++ )
			jj_2_rtns[i] = new JJCalls();
	}


	public void ReInit( java.io.Reader stream ) {
		jj_input_stream.ReInit( stream, 1, 1 );
		token_source.ReInit( jj_input_stream );
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 68; i++ )
			jj_la1[i] = -1;
		for( int i = 0; i < jj_2_rtns.length; i++ )
			jj_2_rtns[i] = new JJCalls();
	}


	public HoclParser( HoclParserTokenManager tm ) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 68; i++ )
			jj_la1[i] = -1;
		for( int i = 0; i < jj_2_rtns.length; i++ )
			jj_2_rtns[i] = new JJCalls();
	}


	public void ReInit( HoclParserTokenManager tm ) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for( int i = 0; i < 68; i++ )
			jj_la1[i] = -1;
		for( int i = 0; i < jj_2_rtns.length; i++ )
			jj_2_rtns[i] = new JJCalls();
	}


	final private Token jj_consume_token( int kind ) throws ParseException {
		Token oldToken;
		if( ( oldToken = token ).next != null )
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if( token.kind == kind ) {
			jj_gen++;
			if( ++jj_gc > 100 ) {
				jj_gc = 0;
				for( int i = 0; i < jj_2_rtns.length; i++ ) {
					JJCalls c = jj_2_rtns[i];
					while( c != null ) {
						if( c.gen < jj_gen )
							c.first = null;
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	static private final class LookaheadSuccess extends Error {
	}

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();


	final private boolean jj_scan_token( int kind ) {
		if( jj_scanpos == jj_lastpos ) {
			jj_la--;
			if( jj_scanpos.next == null ) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if( jj_rescan ) {
			int i = 0;
			Token tok = token;
			while( tok != null && tok != jj_scanpos ) {
				i++;
				tok = tok.next;
			}
			if( tok != null )
				jj_add_error_token( kind, i );
		}
		if( jj_scanpos.kind != kind )
			return true;
		if( jj_la == 0 && jj_scanpos == jj_lastpos )
			throw jj_ls;
		return false;
	}


	final public Token getNextToken() {
		if( token.next != null )
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}


	final public Token getToken( int index ) {
		Token t = lookingAhead ? jj_scanpos : token;
		for( int i = 0; i < index; i++ ) {
			if( t.next != null )
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}


	final private int jj_ntk() {
		if( ( jj_nt = token.next ) == null )
			return ( jj_ntk = ( token.next = token_source.getNextToken() ).kind );
		else
			return ( jj_ntk = jj_nt.kind );
	}

	private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();

	private int[] jj_expentry;

	private int jj_kind = -1;

	private int[] jj_lasttokens = new int[100];

	private int jj_endpos;


	private void jj_add_error_token( int kind, int pos ) {
		if( pos >= 100 )
			return;
		if( pos == jj_endpos + 1 ) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if( jj_endpos != 0 ) {
			jj_expentry = new int[jj_endpos];
			for( int i = 0; i < jj_endpos; i++ ) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			boolean exists = false;
			for( java.util.Enumeration e = jj_expentries.elements(); e
					.hasMoreElements(); ) {
				int[] oldentry = ( int[] ) ( e.nextElement() );
				if( oldentry.length == jj_expentry.length ) {
					exists = true;
					for( int i = 0; i < jj_expentry.length; i++ ) {
						if( oldentry[i] != jj_expentry[i] ) {
							exists = false;
							break;
						}
					}
					if( exists )
						break;
				}
			}
			if( !exists )
				jj_expentries.addElement( jj_expentry );
			if( pos != 0 )
				jj_lasttokens[( jj_endpos = pos ) - 1] = kind;
		}
	}


	public ParseException generateParseException() {
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[131];
		for( int i = 0; i < 131; i++ ) {
			la1tokens[i] = false;
		}
		if( jj_kind >= 0 ) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for( int i = 0; i < 68; i++ ) {
			if( jj_la1[i] == jj_gen ) {
				for( int j = 0; j < 32; j++ ) {
					if( ( jj_la1_0[i] & ( 1 << j ) ) != 0 ) {
						la1tokens[j] = true;
					}
					if( ( jj_la1_1[i] & ( 1 << j ) ) != 0 ) {
						la1tokens[32 + j] = true;
					}
					if( ( jj_la1_2[i] & ( 1 << j ) ) != 0 ) {
						la1tokens[64 + j] = true;
					}
					if( ( jj_la1_3[i] & ( 1 << j ) ) != 0 ) {
						la1tokens[96 + j] = true;
					}
					if( ( jj_la1_4[i] & ( 1 << j ) ) != 0 ) {
						la1tokens[128 + j] = true;
					}
				}
			}
		}
		for( int i = 0; i < 131; i++ ) {
			if( la1tokens[i] ) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement( jj_expentry );
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token( 0, 0 );
		int[][] exptokseq = new int[jj_expentries.size()][];
		for( int i = 0; i < jj_expentries.size(); i++ ) {
			exptokseq[i] = jj_expentries.elementAt( i );
		}
		return new ParseException( token, exptokseq, tokenImage );
	}


	final public void enable_tracing() {
	}


	final public void disable_tracing() {
	}


	final private void jj_rescan_token() {
		jj_rescan = true;
		for( int i = 0; i < 26; i++ ) {
			try {
				JJCalls p = jj_2_rtns[i];
				do {
					if( p.gen > jj_gen ) {
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch( i ) {
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						case 2:
							jj_3_3();
							break;
						case 3:
							jj_3_4();
							break;
						case 4:
							jj_3_5();
							break;
						case 5:
							jj_3_6();
							break;
						case 6:
							jj_3_7();
							break;
						case 7:
							jj_3_8();
							break;
						case 8:
							jj_3_9();
							break;
						case 9:
							jj_3_10();
							break;
						case 10:
							jj_3_11();
							break;
						case 11:
							jj_3_12();
							break;
						case 12:
							jj_3_13();
							break;
						case 13:
							jj_3_14();
							break;
						case 14:
							jj_3_15();
							break;
						case 15:
							jj_3_16();
							break;
						case 16:
							jj_3_17();
							break;
						case 17:
							jj_3_18();
							break;
						case 18:
							jj_3_19();
							break;
						case 19:
							jj_3_20();
							break;
						case 20:
							jj_3_21();
							break;
						case 21:
							jj_3_22();
							break;
						case 22:
							jj_3_23();
							break;
						case 23:
							jj_3_24();
							break;
						case 24:
							jj_3_25();
							break;
						case 25:
							jj_3_26();
							break;
						}
					}
					p = p.next;
				} while( p != null );
			} catch( LookaheadSuccess ls ) {}
		}
		jj_rescan = false;
	}


	final private void jj_save( int index, int xla ) {
		JJCalls p = jj_2_rtns[index];
		while( p.gen > jj_gen ) {
			if( p.next == null ) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls {

		int gen;

		Token first;

		int arg;

		JJCalls next;
	}

	// class ModifierSet

}
